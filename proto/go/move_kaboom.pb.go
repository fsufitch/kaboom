// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v3.19.6
// source: move_kaboom.proto

package kaboomproto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// PawnBump is a Kaboom-specific move replacing the capture.
// The pawn moves diagonally (as in regular capturing) but instead of removing the opponent's piece,
// it "bumps" it to the square directly behind it (in the same direction as the pawn's movement).
type PawnBump struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Vector        *LocationVector        `protobuf:"bytes,1,opt,name=vector,proto3" json:"vector,omitempty"`
	Promotion     PieceKind              `protobuf:"varint,10,opt,name=promotion,proto3,enum=kaboomproto.PieceKind" json:"promotion,omitempty"` // optional promotion piece type
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PawnBump) Reset() {
	*x = PawnBump{}
	mi := &file_move_kaboom_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PawnBump) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PawnBump) ProtoMessage() {}

func (x *PawnBump) ProtoReflect() protoreflect.Message {
	mi := &file_move_kaboom_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PawnBump.ProtoReflect.Descriptor instead.
func (*PawnBump) Descriptor() ([]byte, []int) {
	return file_move_kaboom_proto_rawDescGZIP(), []int{0}
}

func (x *PawnBump) GetVector() *LocationVector {
	if x != nil {
		return x.Vector
	}
	return nil
}

func (x *PawnBump) GetPromotion() PieceKind {
	if x != nil {
		return x.Promotion
	}
	return PieceKind_INVALID_PIECE
}

// PawnExplosion is a Kaboom-specific move where the pawn detonates itself on its current position,
// removing itself and bumping all adjacent pieces (horizontally, vertically, and diagonally).
type PawnExplosion struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Pawn          *Location              `protobuf:"bytes,1,opt,name=pawn,proto3" json:"pawn,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PawnExplosion) Reset() {
	*x = PawnExplosion{}
	mi := &file_move_kaboom_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PawnExplosion) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PawnExplosion) ProtoMessage() {}

func (x *PawnExplosion) ProtoReflect() protoreflect.Message {
	mi := &file_move_kaboom_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PawnExplosion.ProtoReflect.Descriptor instead.
func (*PawnExplosion) Descriptor() ([]byte, []int) {
	return file_move_kaboom_proto_rawDescGZIP(), []int{1}
}

func (x *PawnExplosion) GetPawn() *Location {
	if x != nil {
		return x.Pawn
	}
	return nil
}

// KnightBump is a Kaboom-specific move replacing the capture.
// The knight moves to its target square (as in regular capturing) but instead of removing the opponent's piece,
// it "bumps" it. The direction of the bump may be vertical or horizontal, depending on whether the knight's
// "right angle" move is vertical-first or horizontal-first.
type KnightBump struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MoveVector    *LocationVector        `protobuf:"bytes,1,opt,name=move_vector,json=moveVector,proto3" json:"move_vector,omitempty"`
	BumpVector    *LocationVector        `protobuf:"bytes,2,opt,name=bump_vector,json=bumpVector,proto3" json:"bump_vector,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KnightBump) Reset() {
	*x = KnightBump{}
	mi := &file_move_kaboom_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KnightBump) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KnightBump) ProtoMessage() {}

func (x *KnightBump) ProtoReflect() protoreflect.Message {
	mi := &file_move_kaboom_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KnightBump.ProtoReflect.Descriptor instead.
func (*KnightBump) Descriptor() ([]byte, []int) {
	return file_move_kaboom_proto_rawDescGZIP(), []int{2}
}

func (x *KnightBump) GetMoveVector() *LocationVector {
	if x != nil {
		return x.MoveVector
	}
	return nil
}

func (x *KnightBump) GetBumpVector() *LocationVector {
	if x != nil {
		return x.BumpVector
	}
	return nil
}

// KnightStomp is a Kaboom-specific move where the knight moves to an *empty* target square, and bumps all adjacent pieces
// (horizontally, vertically, and diagonally) away from the target square.
type KnightStomp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Vector        *LocationVector        `protobuf:"bytes,1,opt,name=vector,proto3" json:"vector,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KnightStomp) Reset() {
	*x = KnightStomp{}
	mi := &file_move_kaboom_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KnightStomp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KnightStomp) ProtoMessage() {}

func (x *KnightStomp) ProtoReflect() protoreflect.Message {
	mi := &file_move_kaboom_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KnightStomp.ProtoReflect.Descriptor instead.
func (*KnightStomp) Descriptor() ([]byte, []int) {
	return file_move_kaboom_proto_rawDescGZIP(), []int{3}
}

func (x *KnightStomp) GetVector() *LocationVector {
	if x != nil {
		return x.Vector
	}
	return nil
}

// BishopBump is a Kaboom-specific move replacing the capture.
// The bishop moves to its target square (as in regular capturing) but instead of removing the opponent's piece,
// it "bumps" it along the same diagonal direction to the next square.
type BishopBump struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Vector        *LocationVector        `protobuf:"bytes,1,opt,name=vector,proto3" json:"vector,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BishopBump) Reset() {
	*x = BishopBump{}
	mi := &file_move_kaboom_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BishopBump) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BishopBump) ProtoMessage() {}

func (x *BishopBump) ProtoReflect() protoreflect.Message {
	mi := &file_move_kaboom_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BishopBump.ProtoReflect.Descriptor instead.
func (*BishopBump) Descriptor() ([]byte, []int) {
	return file_move_kaboom_proto_rawDescGZIP(), []int{4}
}

func (x *BishopBump) GetVector() *LocationVector {
	if x != nil {
		return x.Vector
	}
	return nil
}

// BishopSnipe is a Kaboom-specific move. The bishop does not move from its current position,
// but instead "snipes" an opponent's piece located anywhere along its diagonal lines of movement,
// bumping the target piece to the next square along the same diagonal direction.
type BishopSnipe struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Bishop        *Location              `protobuf:"bytes,1,opt,name=bishop,proto3" json:"bishop,omitempty"` // bishop's current position
	Target        *Location              `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"` // position of the opponent's piece to be sniped
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BishopSnipe) Reset() {
	*x = BishopSnipe{}
	mi := &file_move_kaboom_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BishopSnipe) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BishopSnipe) ProtoMessage() {}

func (x *BishopSnipe) ProtoReflect() protoreflect.Message {
	mi := &file_move_kaboom_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BishopSnipe.ProtoReflect.Descriptor instead.
func (*BishopSnipe) Descriptor() ([]byte, []int) {
	return file_move_kaboom_proto_rawDescGZIP(), []int{5}
}

func (x *BishopSnipe) GetBishop() *Location {
	if x != nil {
		return x.Bishop
	}
	return nil
}

func (x *BishopSnipe) GetTarget() *Location {
	if x != nil {
		return x.Target
	}
	return nil
}

// RookBump is a Kaboom-specific move replacing the capture.
// The rook moves to its target square (as in regular capturing) but instead of removing the opponent's piece,
// it "bumps" it along the same rank or file to the next square.
type RookBump struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Vector        *LocationVector        `protobuf:"bytes,1,opt,name=vector,proto3" json:"vector,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RookBump) Reset() {
	*x = RookBump{}
	mi := &file_move_kaboom_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RookBump) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RookBump) ProtoMessage() {}

func (x *RookBump) ProtoReflect() protoreflect.Message {
	mi := &file_move_kaboom_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RookBump.ProtoReflect.Descriptor instead.
func (*RookBump) Descriptor() ([]byte, []int) {
	return file_move_kaboom_proto_rawDescGZIP(), []int{6}
}

func (x *RookBump) GetVector() *LocationVector {
	if x != nil {
		return x.Vector
	}
	return nil
}

// RookTackle is a Kaboom-specific move variant of RookBump.
// The rook moves to its target square (as in regular capturing) but instead of removing the opponent's piece,
// it "tackles" it along the same rank or file, moving the bumped piece two squares away instead of one.
type RookTackle struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Vector        *LocationVector        `protobuf:"bytes,1,opt,name=vector,proto3" json:"vector,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RookTackle) Reset() {
	*x = RookTackle{}
	mi := &file_move_kaboom_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RookTackle) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RookTackle) ProtoMessage() {}

func (x *RookTackle) ProtoReflect() protoreflect.Message {
	mi := &file_move_kaboom_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RookTackle.ProtoReflect.Descriptor instead.
func (*RookTackle) Descriptor() ([]byte, []int) {
	return file_move_kaboom_proto_rawDescGZIP(), []int{7}
}

func (x *RookTackle) GetVector() *LocationVector {
	if x != nil {
		return x.Vector
	}
	return nil
}

// QueenBump is a Kaboom-specific move replacing the capture.
// The queen moves to its target square (as in regular capturing) but instead of removing the
// opponent's piece, it "bumps" it along the same rank, file, or diagonal to the next square.
type QueenBump struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Vector        *LocationVector        `protobuf:"bytes,1,opt,name=vector,proto3" json:"vector,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueenBump) Reset() {
	*x = QueenBump{}
	mi := &file_move_kaboom_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueenBump) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueenBump) ProtoMessage() {}

func (x *QueenBump) ProtoReflect() protoreflect.Message {
	mi := &file_move_kaboom_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueenBump.ProtoReflect.Descriptor instead.
func (*QueenBump) Descriptor() ([]byte, []int) {
	return file_move_kaboom_proto_rawDescGZIP(), []int{8}
}

func (x *QueenBump) GetVector() *LocationVector {
	if x != nil {
		return x.Vector
	}
	return nil
}

// QueenNova is a Kaboom-specific move where the queen detonates itself on its current position,
// removing itself and all pieces (both friendly and opponent) located on the same rank, file, and diagonals.
type QueenNova struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Queen         *Location              `protobuf:"bytes,1,opt,name=queen,proto3" json:"queen,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueenNova) Reset() {
	*x = QueenNova{}
	mi := &file_move_kaboom_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueenNova) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueenNova) ProtoMessage() {}

func (x *QueenNova) ProtoReflect() protoreflect.Message {
	mi := &file_move_kaboom_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueenNova.ProtoReflect.Descriptor instead.
func (*QueenNova) Descriptor() ([]byte, []int) {
	return file_move_kaboom_proto_rawDescGZIP(), []int{9}
}

func (x *QueenNova) GetQueen() *Location {
	if x != nil {
		return x.Queen
	}
	return nil
}

// KingBump is a Kaboom-specific move replacing the capture.
// The king moves to its target square (as in regular capturing) but instead of removing the opponent's piece,
// it "bumps" it to an adjacent square in any direction (horizontally, vertically, or diagonally).
type KingBump struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Vector        *LocationVector        `protobuf:"bytes,1,opt,name=vector,proto3" json:"vector,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KingBump) Reset() {
	*x = KingBump{}
	mi := &file_move_kaboom_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KingBump) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KingBump) ProtoMessage() {}

func (x *KingBump) ProtoReflect() protoreflect.Message {
	mi := &file_move_kaboom_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KingBump.ProtoReflect.Descriptor instead.
func (*KingBump) Descriptor() ([]byte, []int) {
	return file_move_kaboom_proto_rawDescGZIP(), []int{10}
}

func (x *KingBump) GetVector() *LocationVector {
	if x != nil {
		return x.Vector
	}
	return nil
}

// DeployPiece is a Kaboom-specific move where a piece is deployed from the player's bench onto the board.
type DeployPiece struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Vector        *LocationVector        `protobuf:"bytes,1,opt,name=vector,proto3" json:"vector,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeployPiece) Reset() {
	*x = DeployPiece{}
	mi := &file_move_kaboom_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeployPiece) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeployPiece) ProtoMessage() {}

func (x *DeployPiece) ProtoReflect() protoreflect.Message {
	mi := &file_move_kaboom_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeployPiece.ProtoReflect.Descriptor instead.
func (*DeployPiece) Descriptor() ([]byte, []int) {
	return file_move_kaboom_proto_rawDescGZIP(), []int{11}
}

func (x *DeployPiece) GetVector() *LocationVector {
	if x != nil {
		return x.Vector
	}
	return nil
}

// PromotePiece is a Kaboom-specific move for handling the edge case of promoting a pawn that got bumped into the last rank.
type PromotePawn struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Pawn          *Location              `protobuf:"bytes,1,opt,name=pawn,proto3" json:"pawn,omitempty"`
	ToKind        PieceKind              `protobuf:"varint,2,opt,name=to_kind,json=toKind,proto3,enum=kaboomproto.PieceKind" json:"to_kind,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PromotePawn) Reset() {
	*x = PromotePawn{}
	mi := &file_move_kaboom_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PromotePawn) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PromotePawn) ProtoMessage() {}

func (x *PromotePawn) ProtoReflect() protoreflect.Message {
	mi := &file_move_kaboom_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PromotePawn.ProtoReflect.Descriptor instead.
func (*PromotePawn) Descriptor() ([]byte, []int) {
	return file_move_kaboom_proto_rawDescGZIP(), []int{12}
}

func (x *PromotePawn) GetPawn() *Location {
	if x != nil {
		return x.Pawn
	}
	return nil
}

func (x *PromotePawn) GetToKind() PieceKind {
	if x != nil {
		return x.ToKind
	}
	return PieceKind_INVALID_PIECE
}

var File_move_kaboom_proto protoreflect.FileDescriptor

const file_move_kaboom_proto_rawDesc = "" +
	"\n" +
	"\x11move_kaboom.proto\x12\vkaboomproto\x1a\x0elocation.proto\x1a\vpiece.proto\"u\n" +
	"\bPawnBump\x123\n" +
	"\x06vector\x18\x01 \x01(\v2\x1b.kaboomproto.LocationVectorR\x06vector\x124\n" +
	"\tpromotion\x18\n" +
	" \x01(\x0e2\x16.kaboomproto.PieceKindR\tpromotion\":\n" +
	"\rPawnExplosion\x12)\n" +
	"\x04pawn\x18\x01 \x01(\v2\x15.kaboomproto.LocationR\x04pawn\"\x88\x01\n" +
	"\n" +
	"KnightBump\x12<\n" +
	"\vmove_vector\x18\x01 \x01(\v2\x1b.kaboomproto.LocationVectorR\n" +
	"moveVector\x12<\n" +
	"\vbump_vector\x18\x02 \x01(\v2\x1b.kaboomproto.LocationVectorR\n" +
	"bumpVector\"B\n" +
	"\vKnightStomp\x123\n" +
	"\x06vector\x18\x01 \x01(\v2\x1b.kaboomproto.LocationVectorR\x06vector\"A\n" +
	"\n" +
	"BishopBump\x123\n" +
	"\x06vector\x18\x01 \x01(\v2\x1b.kaboomproto.LocationVectorR\x06vector\"k\n" +
	"\vBishopSnipe\x12-\n" +
	"\x06bishop\x18\x01 \x01(\v2\x15.kaboomproto.LocationR\x06bishop\x12-\n" +
	"\x06target\x18\x02 \x01(\v2\x15.kaboomproto.LocationR\x06target\"?\n" +
	"\bRookBump\x123\n" +
	"\x06vector\x18\x01 \x01(\v2\x1b.kaboomproto.LocationVectorR\x06vector\"A\n" +
	"\n" +
	"RookTackle\x123\n" +
	"\x06vector\x18\x01 \x01(\v2\x1b.kaboomproto.LocationVectorR\x06vector\"@\n" +
	"\tQueenBump\x123\n" +
	"\x06vector\x18\x01 \x01(\v2\x1b.kaboomproto.LocationVectorR\x06vector\"8\n" +
	"\tQueenNova\x12+\n" +
	"\x05queen\x18\x01 \x01(\v2\x15.kaboomproto.LocationR\x05queen\"?\n" +
	"\bKingBump\x123\n" +
	"\x06vector\x18\x01 \x01(\v2\x1b.kaboomproto.LocationVectorR\x06vector\"B\n" +
	"\vDeployPiece\x123\n" +
	"\x06vector\x18\x01 \x01(\v2\x1b.kaboomproto.LocationVectorR\x06vector\"i\n" +
	"\vPromotePawn\x12)\n" +
	"\x04pawn\x18\x01 \x01(\v2\x15.kaboomproto.LocationR\x04pawn\x12/\n" +
	"\ato_kind\x18\x02 \x01(\x0e2\x16.kaboomproto.PieceKindR\x06toKindB1Z/github.com/fsufitch/kaboom/proto/go;kaboomprotob\x06proto3"

var (
	file_move_kaboom_proto_rawDescOnce sync.Once
	file_move_kaboom_proto_rawDescData []byte
)

func file_move_kaboom_proto_rawDescGZIP() []byte {
	file_move_kaboom_proto_rawDescOnce.Do(func() {
		file_move_kaboom_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_move_kaboom_proto_rawDesc), len(file_move_kaboom_proto_rawDesc)))
	})
	return file_move_kaboom_proto_rawDescData
}

var file_move_kaboom_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_move_kaboom_proto_goTypes = []any{
	(*PawnBump)(nil),       // 0: kaboomproto.PawnBump
	(*PawnExplosion)(nil),  // 1: kaboomproto.PawnExplosion
	(*KnightBump)(nil),     // 2: kaboomproto.KnightBump
	(*KnightStomp)(nil),    // 3: kaboomproto.KnightStomp
	(*BishopBump)(nil),     // 4: kaboomproto.BishopBump
	(*BishopSnipe)(nil),    // 5: kaboomproto.BishopSnipe
	(*RookBump)(nil),       // 6: kaboomproto.RookBump
	(*RookTackle)(nil),     // 7: kaboomproto.RookTackle
	(*QueenBump)(nil),      // 8: kaboomproto.QueenBump
	(*QueenNova)(nil),      // 9: kaboomproto.QueenNova
	(*KingBump)(nil),       // 10: kaboomproto.KingBump
	(*DeployPiece)(nil),    // 11: kaboomproto.DeployPiece
	(*PromotePawn)(nil),    // 12: kaboomproto.PromotePawn
	(*LocationVector)(nil), // 13: kaboomproto.LocationVector
	(PieceKind)(0),         // 14: kaboomproto.PieceKind
	(*Location)(nil),       // 15: kaboomproto.Location
}
var file_move_kaboom_proto_depIdxs = []int32{
	13, // 0: kaboomproto.PawnBump.vector:type_name -> kaboomproto.LocationVector
	14, // 1: kaboomproto.PawnBump.promotion:type_name -> kaboomproto.PieceKind
	15, // 2: kaboomproto.PawnExplosion.pawn:type_name -> kaboomproto.Location
	13, // 3: kaboomproto.KnightBump.move_vector:type_name -> kaboomproto.LocationVector
	13, // 4: kaboomproto.KnightBump.bump_vector:type_name -> kaboomproto.LocationVector
	13, // 5: kaboomproto.KnightStomp.vector:type_name -> kaboomproto.LocationVector
	13, // 6: kaboomproto.BishopBump.vector:type_name -> kaboomproto.LocationVector
	15, // 7: kaboomproto.BishopSnipe.bishop:type_name -> kaboomproto.Location
	15, // 8: kaboomproto.BishopSnipe.target:type_name -> kaboomproto.Location
	13, // 9: kaboomproto.RookBump.vector:type_name -> kaboomproto.LocationVector
	13, // 10: kaboomproto.RookTackle.vector:type_name -> kaboomproto.LocationVector
	13, // 11: kaboomproto.QueenBump.vector:type_name -> kaboomproto.LocationVector
	15, // 12: kaboomproto.QueenNova.queen:type_name -> kaboomproto.Location
	13, // 13: kaboomproto.KingBump.vector:type_name -> kaboomproto.LocationVector
	13, // 14: kaboomproto.DeployPiece.vector:type_name -> kaboomproto.LocationVector
	15, // 15: kaboomproto.PromotePawn.pawn:type_name -> kaboomproto.Location
	14, // 16: kaboomproto.PromotePawn.to_kind:type_name -> kaboomproto.PieceKind
	17, // [17:17] is the sub-list for method output_type
	17, // [17:17] is the sub-list for method input_type
	17, // [17:17] is the sub-list for extension type_name
	17, // [17:17] is the sub-list for extension extendee
	0,  // [0:17] is the sub-list for field type_name
}

func init() { file_move_kaboom_proto_init() }
func file_move_kaboom_proto_init() {
	if File_move_kaboom_proto != nil {
		return
	}
	file_location_proto_init()
	file_piece_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_move_kaboom_proto_rawDesc), len(file_move_kaboom_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   13,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_move_kaboom_proto_goTypes,
		DependencyIndexes: file_move_kaboom_proto_depIdxs,
		MessageInfos:      file_move_kaboom_proto_msgTypes,
	}.Build()
	File_move_kaboom_proto = out.File
	file_move_kaboom_proto_goTypes = nil
	file_move_kaboom_proto_depIdxs = nil
}
