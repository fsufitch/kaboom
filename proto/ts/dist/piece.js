"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.19.6
// source: piece.proto
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChessPiece = exports.Color = exports.PieceType = exports.protobufPackage = void 0;
exports.pieceTypeFromJSON = pieceTypeFromJSON;
exports.pieceTypeToJSON = pieceTypeToJSON;
exports.colorFromJSON = colorFromJSON;
exports.colorToJSON = colorToJSON;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
exports.protobufPackage = "kaboomproto";
var PieceType;
(function (PieceType) {
    PieceType[PieceType["PAWN"] = 0] = "PAWN";
    PieceType[PieceType["KNIGHT"] = 1] = "KNIGHT";
    PieceType[PieceType["BISHOP"] = 2] = "BISHOP";
    PieceType[PieceType["ROOK"] = 3] = "ROOK";
    PieceType[PieceType["QUEEN"] = 4] = "QUEEN";
    PieceType[PieceType["KING"] = 5] = "KING";
    PieceType[PieceType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(PieceType || (exports.PieceType = PieceType = {}));
function pieceTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "PAWN":
            return PieceType.PAWN;
        case 1:
        case "KNIGHT":
            return PieceType.KNIGHT;
        case 2:
        case "BISHOP":
            return PieceType.BISHOP;
        case 3:
        case "ROOK":
            return PieceType.ROOK;
        case 4:
        case "QUEEN":
            return PieceType.QUEEN;
        case 5:
        case "KING":
            return PieceType.KING;
        case -1:
        case "UNRECOGNIZED":
        default:
            return PieceType.UNRECOGNIZED;
    }
}
function pieceTypeToJSON(object) {
    switch (object) {
        case PieceType.PAWN:
            return "PAWN";
        case PieceType.KNIGHT:
            return "KNIGHT";
        case PieceType.BISHOP:
            return "BISHOP";
        case PieceType.ROOK:
            return "ROOK";
        case PieceType.QUEEN:
            return "QUEEN";
        case PieceType.KING:
            return "KING";
        case PieceType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
var Color;
(function (Color) {
    Color[Color["WHITE"] = 0] = "WHITE";
    Color[Color["BLACK"] = 1] = "BLACK";
    Color[Color["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Color || (exports.Color = Color = {}));
function colorFromJSON(object) {
    switch (object) {
        case 0:
        case "WHITE":
            return Color.WHITE;
        case 1:
        case "BLACK":
            return Color.BLACK;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Color.UNRECOGNIZED;
    }
}
function colorToJSON(object) {
    switch (object) {
        case Color.WHITE:
            return "WHITE";
        case Color.BLACK:
            return "BLACK";
        case Color.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseChessPiece() {
    return { type: 0, color: 0, positionRow: 0, positionCol: 0 };
}
exports.ChessPiece = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.color !== 0) {
            writer.uint32(16).int32(message.color);
        }
        if (message.positionRow !== 0) {
            writer.uint32(24).int32(message.positionRow);
        }
        if (message.positionCol !== 0) {
            writer.uint32(32).int32(message.positionCol);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChessPiece();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.color = reader.int32();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.positionRow = reader.int32();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.positionCol = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? pieceTypeFromJSON(object.type) : 0,
            color: isSet(object.color) ? colorFromJSON(object.color) : 0,
            positionRow: isSet(object.positionRow) ? globalThis.Number(object.positionRow) : 0,
            positionCol: isSet(object.positionCol) ? globalThis.Number(object.positionCol) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.type !== 0) {
            obj.type = pieceTypeToJSON(message.type);
        }
        if (message.color !== 0) {
            obj.color = colorToJSON(message.color);
        }
        if (message.positionRow !== 0) {
            obj.positionRow = Math.round(message.positionRow);
        }
        if (message.positionCol !== 0) {
            obj.positionCol = Math.round(message.positionCol);
        }
        return obj;
    },
    create(base) {
        return exports.ChessPiece.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseChessPiece();
        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;
        message.color = (_b = object.color) !== null && _b !== void 0 ? _b : 0;
        message.positionRow = (_c = object.positionRow) !== null && _c !== void 0 ? _c : 0;
        message.positionCol = (_d = object.positionCol) !== null && _d !== void 0 ? _d : 0;
        return message;
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=piece.js.map