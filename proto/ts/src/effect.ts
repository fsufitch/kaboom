// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.19.6
// source: effect.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { ChessPiece, PieceKind, pieceKindFromJSON, pieceKindToJSON } from "./piece";
import { Position, Vector, ZoneKind, zoneKindFromJSON, zoneKindToJSON } from "./position";
import { VisualHint } from "./visual_hint";

export const protobufPackage = "kaboomproto";

/**
 * Effect represents a single "thing that happens in the game".
 * Effects are "actionable" elements of the game "state machine".
 * Given a game state, you can apply an Effect to get the next state.
 */
export interface Effect {
  uuid: string;
  boardUuid: string;
  /** Human-readable reason for the effect; for logging/debugging. */
  why: string;
  nothingHappens?: EffectNothingHappens | undefined;
  pieceCreated?: EffectPieceCreated | undefined;
  pieceDeleted?: EffectPieceDeleted | undefined;
  pieceMoved?: EffectPieceMoved | undefined;
  pieceCaptured?: EffectPieceCaptured | undefined;
  pieceBumped?: EffectPieceBumped | undefined;
  piecePromoted?: EffectPiecePromoted | undefined;
  pieceDeployed?: EffectPieceDeployed | undefined;
  pieceTransfer?: EffectPieceTransfer | undefined;
  win?:
    | EffectWin
    | undefined;
  /** Visual hints to help the frontend represent this effect. */
  visualHints: VisualHint[];
}

/** Effect__NothingHappens is a no-op effect; used for timing placeholders, or for visual hints that don't correspond to game state changes. */
export interface EffectNothingHappens {
}

/**
 * Effect__PieceCreated represents the creation of a new piece on the board.
 * This is NOT equivalent to deployment, only when an entirely new piece is instantiated.
 */
export interface EffectPieceCreated {
  piece?: ChessPiece | undefined;
}

/**
 * Effect__PieceDeleted represents the removal of a piece from the game entirely.
 * This is NOT equivalent to capture, only when a piece is destroyed utterly somehow.
 */
export interface EffectPieceDeleted {
  pieceUuid: string;
}

/**
 * Effect__PieceMoved represents a piece moving from one position to another on the same board.
 * If the piece's movement is due to a bump action, use PieceBumped instead.
 */
export interface EffectPieceMoved {
  pieceUuid: string;
  vector?: Vector | undefined;
}

/** Effect__PieceCaptured represents a piece being captured and moved to its board's graveyard zone. */
export interface EffectPieceCaptured {
  pieceUuid: string;
}

/**
 * Effect__PieceBumped represents a piece being bumped from one position to another on the same board.
 * It is similar to Effect__PieceMoved, but specifically indicates that the piece was forced to move by another piece's action.
 */
export interface EffectPieceBumped {
  pieceUuid: string;
  vector?: Vector | undefined;
}

/** Effect__PiecePromoted represents a piece being promoted to a different kind (e.g., pawn to queen). */
export interface EffectPiecePromoted {
  pieceUuid: string;
  toKind: PieceKind;
}

/** Effect__PieceDeployed represents a piece being placed from the bench zone onto the board. */
export interface EffectPieceDeployed {
  pieceUuid: string;
  toPosition?: Position | undefined;
}

/**
 * Effect__PieceTransfer represents a full mutation of a piece's location (potentially across position, zone, and board).
 * Do NOT use this for captures or deploys. Use it for handing off pieces between players' boards in bughouse, or similar.
 */
export interface EffectPieceTransfer {
  pieceUuid: string;
  toBoardUuid: string;
  toZone: ZoneKind;
  toPosition?: Position | undefined;
}

/** Effect__Win represents a player winning the game on a specific board. */
export interface EffectWin {
  winningPlayerUuid: string;
}

function createBaseEffect(): Effect {
  return {
    uuid: "",
    boardUuid: "",
    why: "",
    nothingHappens: undefined,
    pieceCreated: undefined,
    pieceDeleted: undefined,
    pieceMoved: undefined,
    pieceCaptured: undefined,
    pieceBumped: undefined,
    piecePromoted: undefined,
    pieceDeployed: undefined,
    pieceTransfer: undefined,
    win: undefined,
    visualHints: [],
  };
}

export const Effect = {
  encode(message: Effect, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.boardUuid !== "") {
      writer.uint32(18).string(message.boardUuid);
    }
    if (message.why !== "") {
      writer.uint32(26).string(message.why);
    }
    if (message.nothingHappens !== undefined) {
      EffectNothingHappens.encode(message.nothingHappens, writer.uint32(82).fork()).ldelim();
    }
    if (message.pieceCreated !== undefined) {
      EffectPieceCreated.encode(message.pieceCreated, writer.uint32(242).fork()).ldelim();
    }
    if (message.pieceDeleted !== undefined) {
      EffectPieceDeleted.encode(message.pieceDeleted, writer.uint32(250).fork()).ldelim();
    }
    if (message.pieceMoved !== undefined) {
      EffectPieceMoved.encode(message.pieceMoved, writer.uint32(258).fork()).ldelim();
    }
    if (message.pieceCaptured !== undefined) {
      EffectPieceCaptured.encode(message.pieceCaptured, writer.uint32(266).fork()).ldelim();
    }
    if (message.pieceBumped !== undefined) {
      EffectPieceBumped.encode(message.pieceBumped, writer.uint32(290).fork()).ldelim();
    }
    if (message.piecePromoted !== undefined) {
      EffectPiecePromoted.encode(message.piecePromoted, writer.uint32(298).fork()).ldelim();
    }
    if (message.pieceDeployed !== undefined) {
      EffectPieceDeployed.encode(message.pieceDeployed, writer.uint32(274).fork()).ldelim();
    }
    if (message.pieceTransfer !== undefined) {
      EffectPieceTransfer.encode(message.pieceTransfer, writer.uint32(282).fork()).ldelim();
    }
    if (message.win !== undefined) {
      EffectWin.encode(message.win, writer.uint32(322).fork()).ldelim();
    }
    for (const v of message.visualHints) {
      VisualHint.encode(v!, writer.uint32(802).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Effect {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.boardUuid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.why = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.nothingHappens = EffectNothingHappens.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.pieceCreated = EffectPieceCreated.decode(reader, reader.uint32());
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.pieceDeleted = EffectPieceDeleted.decode(reader, reader.uint32());
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.pieceMoved = EffectPieceMoved.decode(reader, reader.uint32());
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }

          message.pieceCaptured = EffectPieceCaptured.decode(reader, reader.uint32());
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.pieceBumped = EffectPieceBumped.decode(reader, reader.uint32());
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }

          message.piecePromoted = EffectPiecePromoted.decode(reader, reader.uint32());
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.pieceDeployed = EffectPieceDeployed.decode(reader, reader.uint32());
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.pieceTransfer = EffectPieceTransfer.decode(reader, reader.uint32());
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }

          message.win = EffectWin.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.visualHints.push(VisualHint.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Effect {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      boardUuid: isSet(object.boardUuid) ? globalThis.String(object.boardUuid) : "",
      why: isSet(object.why) ? globalThis.String(object.why) : "",
      nothingHappens: isSet(object.nothingHappens) ? EffectNothingHappens.fromJSON(object.nothingHappens) : undefined,
      pieceCreated: isSet(object.pieceCreated) ? EffectPieceCreated.fromJSON(object.pieceCreated) : undefined,
      pieceDeleted: isSet(object.pieceDeleted) ? EffectPieceDeleted.fromJSON(object.pieceDeleted) : undefined,
      pieceMoved: isSet(object.pieceMoved) ? EffectPieceMoved.fromJSON(object.pieceMoved) : undefined,
      pieceCaptured: isSet(object.pieceCaptured) ? EffectPieceCaptured.fromJSON(object.pieceCaptured) : undefined,
      pieceBumped: isSet(object.pieceBumped) ? EffectPieceBumped.fromJSON(object.pieceBumped) : undefined,
      piecePromoted: isSet(object.piecePromoted) ? EffectPiecePromoted.fromJSON(object.piecePromoted) : undefined,
      pieceDeployed: isSet(object.pieceDeployed) ? EffectPieceDeployed.fromJSON(object.pieceDeployed) : undefined,
      pieceTransfer: isSet(object.pieceTransfer) ? EffectPieceTransfer.fromJSON(object.pieceTransfer) : undefined,
      win: isSet(object.win) ? EffectWin.fromJSON(object.win) : undefined,
      visualHints: globalThis.Array.isArray(object?.visualHints)
        ? object.visualHints.map((e: any) => VisualHint.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Effect): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.boardUuid !== "") {
      obj.boardUuid = message.boardUuid;
    }
    if (message.why !== "") {
      obj.why = message.why;
    }
    if (message.nothingHappens !== undefined) {
      obj.nothingHappens = EffectNothingHappens.toJSON(message.nothingHappens);
    }
    if (message.pieceCreated !== undefined) {
      obj.pieceCreated = EffectPieceCreated.toJSON(message.pieceCreated);
    }
    if (message.pieceDeleted !== undefined) {
      obj.pieceDeleted = EffectPieceDeleted.toJSON(message.pieceDeleted);
    }
    if (message.pieceMoved !== undefined) {
      obj.pieceMoved = EffectPieceMoved.toJSON(message.pieceMoved);
    }
    if (message.pieceCaptured !== undefined) {
      obj.pieceCaptured = EffectPieceCaptured.toJSON(message.pieceCaptured);
    }
    if (message.pieceBumped !== undefined) {
      obj.pieceBumped = EffectPieceBumped.toJSON(message.pieceBumped);
    }
    if (message.piecePromoted !== undefined) {
      obj.piecePromoted = EffectPiecePromoted.toJSON(message.piecePromoted);
    }
    if (message.pieceDeployed !== undefined) {
      obj.pieceDeployed = EffectPieceDeployed.toJSON(message.pieceDeployed);
    }
    if (message.pieceTransfer !== undefined) {
      obj.pieceTransfer = EffectPieceTransfer.toJSON(message.pieceTransfer);
    }
    if (message.win !== undefined) {
      obj.win = EffectWin.toJSON(message.win);
    }
    if (message.visualHints?.length) {
      obj.visualHints = message.visualHints.map((e) => VisualHint.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Effect>, I>>(base?: I): Effect {
    return Effect.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Effect>, I>>(object: I): Effect {
    const message = createBaseEffect();
    message.uuid = object.uuid ?? "";
    message.boardUuid = object.boardUuid ?? "";
    message.why = object.why ?? "";
    message.nothingHappens = (object.nothingHappens !== undefined && object.nothingHappens !== null)
      ? EffectNothingHappens.fromPartial(object.nothingHappens)
      : undefined;
    message.pieceCreated = (object.pieceCreated !== undefined && object.pieceCreated !== null)
      ? EffectPieceCreated.fromPartial(object.pieceCreated)
      : undefined;
    message.pieceDeleted = (object.pieceDeleted !== undefined && object.pieceDeleted !== null)
      ? EffectPieceDeleted.fromPartial(object.pieceDeleted)
      : undefined;
    message.pieceMoved = (object.pieceMoved !== undefined && object.pieceMoved !== null)
      ? EffectPieceMoved.fromPartial(object.pieceMoved)
      : undefined;
    message.pieceCaptured = (object.pieceCaptured !== undefined && object.pieceCaptured !== null)
      ? EffectPieceCaptured.fromPartial(object.pieceCaptured)
      : undefined;
    message.pieceBumped = (object.pieceBumped !== undefined && object.pieceBumped !== null)
      ? EffectPieceBumped.fromPartial(object.pieceBumped)
      : undefined;
    message.piecePromoted = (object.piecePromoted !== undefined && object.piecePromoted !== null)
      ? EffectPiecePromoted.fromPartial(object.piecePromoted)
      : undefined;
    message.pieceDeployed = (object.pieceDeployed !== undefined && object.pieceDeployed !== null)
      ? EffectPieceDeployed.fromPartial(object.pieceDeployed)
      : undefined;
    message.pieceTransfer = (object.pieceTransfer !== undefined && object.pieceTransfer !== null)
      ? EffectPieceTransfer.fromPartial(object.pieceTransfer)
      : undefined;
    message.win = (object.win !== undefined && object.win !== null) ? EffectWin.fromPartial(object.win) : undefined;
    message.visualHints = object.visualHints?.map((e) => VisualHint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEffectNothingHappens(): EffectNothingHappens {
  return {};
}

export const EffectNothingHappens = {
  encode(_: EffectNothingHappens, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EffectNothingHappens {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectNothingHappens();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EffectNothingHappens {
    return {};
  },

  toJSON(_: EffectNothingHappens): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<EffectNothingHappens>, I>>(base?: I): EffectNothingHappens {
    return EffectNothingHappens.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EffectNothingHappens>, I>>(_: I): EffectNothingHappens {
    const message = createBaseEffectNothingHappens();
    return message;
  },
};

function createBaseEffectPieceCreated(): EffectPieceCreated {
  return { piece: undefined };
}

export const EffectPieceCreated = {
  encode(message: EffectPieceCreated, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.piece !== undefined) {
      ChessPiece.encode(message.piece, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EffectPieceCreated {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectPieceCreated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.piece = ChessPiece.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectPieceCreated {
    return { piece: isSet(object.piece) ? ChessPiece.fromJSON(object.piece) : undefined };
  },

  toJSON(message: EffectPieceCreated): unknown {
    const obj: any = {};
    if (message.piece !== undefined) {
      obj.piece = ChessPiece.toJSON(message.piece);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EffectPieceCreated>, I>>(base?: I): EffectPieceCreated {
    return EffectPieceCreated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EffectPieceCreated>, I>>(object: I): EffectPieceCreated {
    const message = createBaseEffectPieceCreated();
    message.piece = (object.piece !== undefined && object.piece !== null)
      ? ChessPiece.fromPartial(object.piece)
      : undefined;
    return message;
  },
};

function createBaseEffectPieceDeleted(): EffectPieceDeleted {
  return { pieceUuid: "" };
}

export const EffectPieceDeleted = {
  encode(message: EffectPieceDeleted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pieceUuid !== "") {
      writer.uint32(10).string(message.pieceUuid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EffectPieceDeleted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectPieceDeleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pieceUuid = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectPieceDeleted {
    return { pieceUuid: isSet(object.pieceUuid) ? globalThis.String(object.pieceUuid) : "" };
  },

  toJSON(message: EffectPieceDeleted): unknown {
    const obj: any = {};
    if (message.pieceUuid !== "") {
      obj.pieceUuid = message.pieceUuid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EffectPieceDeleted>, I>>(base?: I): EffectPieceDeleted {
    return EffectPieceDeleted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EffectPieceDeleted>, I>>(object: I): EffectPieceDeleted {
    const message = createBaseEffectPieceDeleted();
    message.pieceUuid = object.pieceUuid ?? "";
    return message;
  },
};

function createBaseEffectPieceMoved(): EffectPieceMoved {
  return { pieceUuid: "", vector: undefined };
}

export const EffectPieceMoved = {
  encode(message: EffectPieceMoved, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pieceUuid !== "") {
      writer.uint32(10).string(message.pieceUuid);
    }
    if (message.vector !== undefined) {
      Vector.encode(message.vector, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EffectPieceMoved {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectPieceMoved();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pieceUuid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vector = Vector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectPieceMoved {
    return {
      pieceUuid: isSet(object.pieceUuid) ? globalThis.String(object.pieceUuid) : "",
      vector: isSet(object.vector) ? Vector.fromJSON(object.vector) : undefined,
    };
  },

  toJSON(message: EffectPieceMoved): unknown {
    const obj: any = {};
    if (message.pieceUuid !== "") {
      obj.pieceUuid = message.pieceUuid;
    }
    if (message.vector !== undefined) {
      obj.vector = Vector.toJSON(message.vector);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EffectPieceMoved>, I>>(base?: I): EffectPieceMoved {
    return EffectPieceMoved.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EffectPieceMoved>, I>>(object: I): EffectPieceMoved {
    const message = createBaseEffectPieceMoved();
    message.pieceUuid = object.pieceUuid ?? "";
    message.vector = (object.vector !== undefined && object.vector !== null)
      ? Vector.fromPartial(object.vector)
      : undefined;
    return message;
  },
};

function createBaseEffectPieceCaptured(): EffectPieceCaptured {
  return { pieceUuid: "" };
}

export const EffectPieceCaptured = {
  encode(message: EffectPieceCaptured, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pieceUuid !== "") {
      writer.uint32(10).string(message.pieceUuid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EffectPieceCaptured {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectPieceCaptured();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pieceUuid = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectPieceCaptured {
    return { pieceUuid: isSet(object.pieceUuid) ? globalThis.String(object.pieceUuid) : "" };
  },

  toJSON(message: EffectPieceCaptured): unknown {
    const obj: any = {};
    if (message.pieceUuid !== "") {
      obj.pieceUuid = message.pieceUuid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EffectPieceCaptured>, I>>(base?: I): EffectPieceCaptured {
    return EffectPieceCaptured.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EffectPieceCaptured>, I>>(object: I): EffectPieceCaptured {
    const message = createBaseEffectPieceCaptured();
    message.pieceUuid = object.pieceUuid ?? "";
    return message;
  },
};

function createBaseEffectPieceBumped(): EffectPieceBumped {
  return { pieceUuid: "", vector: undefined };
}

export const EffectPieceBumped = {
  encode(message: EffectPieceBumped, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pieceUuid !== "") {
      writer.uint32(10).string(message.pieceUuid);
    }
    if (message.vector !== undefined) {
      Vector.encode(message.vector, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EffectPieceBumped {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectPieceBumped();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pieceUuid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vector = Vector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectPieceBumped {
    return {
      pieceUuid: isSet(object.pieceUuid) ? globalThis.String(object.pieceUuid) : "",
      vector: isSet(object.vector) ? Vector.fromJSON(object.vector) : undefined,
    };
  },

  toJSON(message: EffectPieceBumped): unknown {
    const obj: any = {};
    if (message.pieceUuid !== "") {
      obj.pieceUuid = message.pieceUuid;
    }
    if (message.vector !== undefined) {
      obj.vector = Vector.toJSON(message.vector);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EffectPieceBumped>, I>>(base?: I): EffectPieceBumped {
    return EffectPieceBumped.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EffectPieceBumped>, I>>(object: I): EffectPieceBumped {
    const message = createBaseEffectPieceBumped();
    message.pieceUuid = object.pieceUuid ?? "";
    message.vector = (object.vector !== undefined && object.vector !== null)
      ? Vector.fromPartial(object.vector)
      : undefined;
    return message;
  },
};

function createBaseEffectPiecePromoted(): EffectPiecePromoted {
  return { pieceUuid: "", toKind: 0 };
}

export const EffectPiecePromoted = {
  encode(message: EffectPiecePromoted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pieceUuid !== "") {
      writer.uint32(10).string(message.pieceUuid);
    }
    if (message.toKind !== 0) {
      writer.uint32(16).int32(message.toKind);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EffectPiecePromoted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectPiecePromoted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pieceUuid = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toKind = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectPiecePromoted {
    return {
      pieceUuid: isSet(object.pieceUuid) ? globalThis.String(object.pieceUuid) : "",
      toKind: isSet(object.toKind) ? pieceKindFromJSON(object.toKind) : 0,
    };
  },

  toJSON(message: EffectPiecePromoted): unknown {
    const obj: any = {};
    if (message.pieceUuid !== "") {
      obj.pieceUuid = message.pieceUuid;
    }
    if (message.toKind !== 0) {
      obj.toKind = pieceKindToJSON(message.toKind);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EffectPiecePromoted>, I>>(base?: I): EffectPiecePromoted {
    return EffectPiecePromoted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EffectPiecePromoted>, I>>(object: I): EffectPiecePromoted {
    const message = createBaseEffectPiecePromoted();
    message.pieceUuid = object.pieceUuid ?? "";
    message.toKind = object.toKind ?? 0;
    return message;
  },
};

function createBaseEffectPieceDeployed(): EffectPieceDeployed {
  return { pieceUuid: "", toPosition: undefined };
}

export const EffectPieceDeployed = {
  encode(message: EffectPieceDeployed, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pieceUuid !== "") {
      writer.uint32(10).string(message.pieceUuid);
    }
    if (message.toPosition !== undefined) {
      Position.encode(message.toPosition, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EffectPieceDeployed {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectPieceDeployed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pieceUuid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.toPosition = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectPieceDeployed {
    return {
      pieceUuid: isSet(object.pieceUuid) ? globalThis.String(object.pieceUuid) : "",
      toPosition: isSet(object.toPosition) ? Position.fromJSON(object.toPosition) : undefined,
    };
  },

  toJSON(message: EffectPieceDeployed): unknown {
    const obj: any = {};
    if (message.pieceUuid !== "") {
      obj.pieceUuid = message.pieceUuid;
    }
    if (message.toPosition !== undefined) {
      obj.toPosition = Position.toJSON(message.toPosition);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EffectPieceDeployed>, I>>(base?: I): EffectPieceDeployed {
    return EffectPieceDeployed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EffectPieceDeployed>, I>>(object: I): EffectPieceDeployed {
    const message = createBaseEffectPieceDeployed();
    message.pieceUuid = object.pieceUuid ?? "";
    message.toPosition = (object.toPosition !== undefined && object.toPosition !== null)
      ? Position.fromPartial(object.toPosition)
      : undefined;
    return message;
  },
};

function createBaseEffectPieceTransfer(): EffectPieceTransfer {
  return { pieceUuid: "", toBoardUuid: "", toZone: 0, toPosition: undefined };
}

export const EffectPieceTransfer = {
  encode(message: EffectPieceTransfer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pieceUuid !== "") {
      writer.uint32(10).string(message.pieceUuid);
    }
    if (message.toBoardUuid !== "") {
      writer.uint32(18).string(message.toBoardUuid);
    }
    if (message.toZone !== 0) {
      writer.uint32(24).int32(message.toZone);
    }
    if (message.toPosition !== undefined) {
      Position.encode(message.toPosition, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EffectPieceTransfer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectPieceTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pieceUuid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.toBoardUuid = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.toZone = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.toPosition = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectPieceTransfer {
    return {
      pieceUuid: isSet(object.pieceUuid) ? globalThis.String(object.pieceUuid) : "",
      toBoardUuid: isSet(object.toBoardUuid) ? globalThis.String(object.toBoardUuid) : "",
      toZone: isSet(object.toZone) ? zoneKindFromJSON(object.toZone) : 0,
      toPosition: isSet(object.toPosition) ? Position.fromJSON(object.toPosition) : undefined,
    };
  },

  toJSON(message: EffectPieceTransfer): unknown {
    const obj: any = {};
    if (message.pieceUuid !== "") {
      obj.pieceUuid = message.pieceUuid;
    }
    if (message.toBoardUuid !== "") {
      obj.toBoardUuid = message.toBoardUuid;
    }
    if (message.toZone !== 0) {
      obj.toZone = zoneKindToJSON(message.toZone);
    }
    if (message.toPosition !== undefined) {
      obj.toPosition = Position.toJSON(message.toPosition);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EffectPieceTransfer>, I>>(base?: I): EffectPieceTransfer {
    return EffectPieceTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EffectPieceTransfer>, I>>(object: I): EffectPieceTransfer {
    const message = createBaseEffectPieceTransfer();
    message.pieceUuid = object.pieceUuid ?? "";
    message.toBoardUuid = object.toBoardUuid ?? "";
    message.toZone = object.toZone ?? 0;
    message.toPosition = (object.toPosition !== undefined && object.toPosition !== null)
      ? Position.fromPartial(object.toPosition)
      : undefined;
    return message;
  },
};

function createBaseEffectWin(): EffectWin {
  return { winningPlayerUuid: "" };
}

export const EffectWin = {
  encode(message: EffectWin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.winningPlayerUuid !== "") {
      writer.uint32(10).string(message.winningPlayerUuid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EffectWin {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectWin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.winningPlayerUuid = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectWin {
    return { winningPlayerUuid: isSet(object.winningPlayerUuid) ? globalThis.String(object.winningPlayerUuid) : "" };
  },

  toJSON(message: EffectWin): unknown {
    const obj: any = {};
    if (message.winningPlayerUuid !== "") {
      obj.winningPlayerUuid = message.winningPlayerUuid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EffectWin>, I>>(base?: I): EffectWin {
    return EffectWin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EffectWin>, I>>(object: I): EffectWin {
    const message = createBaseEffectWin();
    message.winningPlayerUuid = object.winningPlayerUuid ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
