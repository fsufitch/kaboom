// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.19.6
// source: move.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { PieceKind, pieceKindFromJSON, pieceKindToJSON } from "./piece";
import { Position } from "./position";

export const protobufPackage = "kaboomproto";

export interface KaboomMove {
  cPawnMove?: CPawnMove | undefined;
  cPawnCapture?: CPawnCapture | undefined;
  kPawnBump?: KPawnBump | undefined;
  kPawnExplosion?: KPawnExplosion | undefined;
  cKnightMove?: CKnightMove | undefined;
  cKnightCapture?: CKnightCapture | undefined;
  kKnightBump?: KKnightBump | undefined;
  kKnightStomp?: KKnightStomp | undefined;
  cBishopMove?: CBishopMove | undefined;
  cBishopCapture?: CBishopCapture | undefined;
  kBishopBump?: KBishopBump | undefined;
  kBishopSnipe?: KBishopSnipe | undefined;
  cRookMove?: CRookMove | undefined;
  cRookCapture?: CRookCapture | undefined;
  kRookBump?: KRookBump | undefined;
  kRookTackle?: KRookTackle | undefined;
  cQueenMove?: CQueenMove | undefined;
  cQueenCapture?: CQueenCapture | undefined;
  kQueenBump?: KQueenBump | undefined;
  kQueenNova?: KQueenNova | undefined;
  cKingMove?: CKingMove | undefined;
  cKingCapture?: CKingCapture | undefined;
  kKingBump?: KKingBump | undefined;
  kKingControl?: KKingControl | undefined;
}

/**
 * C_PawnMove is a normal pawn move in regular chess rules.
 * It encompasses single and double square advances.
 */
export interface CPawnMove {
  from?: Position | undefined;
  to?:
    | Position
    | undefined;
  /** optional promotion piece type */
  promotion: PieceKind;
}

/**
 * C_PawnCapture is a normal pawn capture move in regular chess rules.
 * It encompasses regular and en passant captures.
 */
export interface CPawnCapture {
  from?: Position | undefined;
  to?:
    | Position
    | undefined;
  /** optional promotion piece type */
  promotion: PieceKind;
}

/**
 * K_PawnBump is a Kaboom-specific move replacing the capture.
 * The pawn moves diagonally (as in regular capturing) but instead of removing the opponent's piece,
 * it "bumps" it to the square directly behind it (in the same direction as the pawn's movement).
 */
export interface KPawnBump {
  from?: Position | undefined;
  to?:
    | Position
    | undefined;
  /** optional promotion piece type */
  promotion: PieceKind;
}

/**
 * K_PawnExplosion is a Kaboom-specific move where the pawn detonates itself on its current position,
 * removing itself and bumping all adjacent pieces (horizontally, vertically, and diagonally).
 */
export interface KPawnExplosion {
  position?: Position | undefined;
}

/** C_KnightMove is a normal knight move in regular chess rules. */
export interface CKnightMove {
  from?: Position | undefined;
  to?: Position | undefined;
}

/** C_KnightCapture is a normal knight capture move in regular chess rules. */
export interface CKnightCapture {
  from?: Position | undefined;
  to?: Position | undefined;
}

/**
 * K_KnightBump is a Kaboom-specific move replacing the capture.
 * The knight moves to its target square (as in regular capturing) but instead of removing the opponent's piece,
 * it "bumps" it. The direction of the bump may be vertical or horizontal, depending on whether the knight's
 * "right angle" move is vertical-first or horizontal-first.
 */
export interface KKnightBump {
  from?: Position | undefined;
  to?: Position | undefined;
  bumpDirection: KKnightBump_BumpDirection;
}

export enum KKnightBump_BumpDirection {
  BUMP_DIRECTION_UNKNOWN = 0,
  /** BUMP_DIRECTION_HORIZONTAL - bump horizontally */
  BUMP_DIRECTION_HORIZONTAL = 1,
  /** BUMP_DIRECTION_VERTICAL - bump vertically */
  BUMP_DIRECTION_VERTICAL = 2,
  UNRECOGNIZED = -1,
}

export function kKnightBump_BumpDirectionFromJSON(object: any): KKnightBump_BumpDirection {
  switch (object) {
    case 0:
    case "BUMP_DIRECTION_UNKNOWN":
      return KKnightBump_BumpDirection.BUMP_DIRECTION_UNKNOWN;
    case 1:
    case "BUMP_DIRECTION_HORIZONTAL":
      return KKnightBump_BumpDirection.BUMP_DIRECTION_HORIZONTAL;
    case 2:
    case "BUMP_DIRECTION_VERTICAL":
      return KKnightBump_BumpDirection.BUMP_DIRECTION_VERTICAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return KKnightBump_BumpDirection.UNRECOGNIZED;
  }
}

export function kKnightBump_BumpDirectionToJSON(object: KKnightBump_BumpDirection): string {
  switch (object) {
    case KKnightBump_BumpDirection.BUMP_DIRECTION_UNKNOWN:
      return "BUMP_DIRECTION_UNKNOWN";
    case KKnightBump_BumpDirection.BUMP_DIRECTION_HORIZONTAL:
      return "BUMP_DIRECTION_HORIZONTAL";
    case KKnightBump_BumpDirection.BUMP_DIRECTION_VERTICAL:
      return "BUMP_DIRECTION_VERTICAL";
    case KKnightBump_BumpDirection.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * K_KnightStomp is a Kaboom-specific move where the knight moves to an *empty* target square, and bumps all adjacent pieces
 * (horizontally, vertically, and diagonally) away from the target square.
 */
export interface KKnightStomp {
  from?: Position | undefined;
  to?: Position | undefined;
}

/** C_BishopMove is a normal bishop move in regular chess rules. */
export interface CBishopMove {
  from?: Position | undefined;
  to?: Position | undefined;
}

/** C_BishopCapture is a normal bishop capture move in regular chess rules. */
export interface CBishopCapture {
  from?: Position | undefined;
  to?: Position | undefined;
}

/**
 * K_BishopBump is a Kaboom-specific move replacing the capture.
 * The bishop moves to its target square (as in regular capturing) but instead of removing the opponent's piece,
 * it "bumps" it along the same diagonal direction to the next square.
 */
export interface KBishopBump {
  from?: Position | undefined;
  to?: Position | undefined;
}

/**
 * K_BishopSnipe is a Kaboom-specific move. The bishop does not move from its current position,
 * but instead "snipes" an opponent's piece located anywhere along its diagonal lines of movement,
 * bumping the target piece to the next square along the same diagonal direction.
 */
export interface KBishopSnipe {
  /** bishop's current position */
  from?:
    | Position
    | undefined;
  /** position of the opponent's piece to be sniped */
  target?: Position | undefined;
}

/** C_RookMove is a normal rook move in regular chess rules. */
export interface CRookMove {
  from?: Position | undefined;
  to?: Position | undefined;
}

/** C_RookCapture is a normal rook capture move in regular chess rules. */
export interface CRookCapture {
  from?: Position | undefined;
  to?: Position | undefined;
}

/**
 * K_RookBump is a Kaboom-specific move replacing the capture.
 * The rook moves to its target square (as in regular capturing) but instead of removing the opponent's piece,
 * it "bumps" it along the same rank or file to the next square.
 */
export interface KRookBump {
  from?: Position | undefined;
  to?: Position | undefined;
}

/**
 * K_RookTackle is a Kaboom-specific move variant of K_RookBump.
 * The rook moves to its target square (as in regular capturing) but instead of removing the opponent's piece,
 * it "tackles" it along the same rank or file, moving the bumped piece two squares away instead of one.
 */
export interface KRookTackle {
  from?: Position | undefined;
  to?: Position | undefined;
}

/** C_QueenMove is a normal queen move in regular chess rules. */
export interface CQueenMove {
  from?: Position | undefined;
  to?: Position | undefined;
}

/** C_QueenCapture is a normal queen capture move in regular chess rules. */
export interface CQueenCapture {
  from?: Position | undefined;
  to?: Position | undefined;
}

/**
 * K_QueenBump is a Kaboom-specific move replacing the capture.
 * The queen moves to its target square (as in regular capturing) but instead of removing the
 * opponent's piece, it "bumps" it along the same rank, file, or diagonal to the next square.
 */
export interface KQueenBump {
  from?: Position | undefined;
  to?: Position | undefined;
}

/**
 * K_QueenNova is a Kaboom-specific move where the queen detonates itself on its current position,
 * removing itself and all pieces (both friendly and opponent) located on the same rank, file, and diagonals.
 */
export interface KQueenNova {
  position?: Position | undefined;
}

/** C_KingMove is a normal king move in regular chess rules. */
export interface CKingMove {
  from?: Position | undefined;
  to?: Position | undefined;
}

/** C_KingCapture is a normal king capture move in regular chess rules. */
export interface CKingCapture {
  from?: Position | undefined;
  to?: Position | undefined;
}

/** C_KingCastle is a normal king castling move in regular chess rules. */
export interface CKingCastle {
  kingFrom?: Position | undefined;
  kingTo?: Position | undefined;
  rookFrom?: Position | undefined;
  rookTo?: Position | undefined;
}

/**
 * K_KingBump is a Kaboom-specific move replacing the capture.
 * The king moves to its target square (as in regular capturing) but instead of removing the opponent's piece,
 * it "bumps" it to an adjacent square in any direction (horizontally, vertically, or diagonally).
 */
export interface KKingBump {
  from?: Position | undefined;
  to?: Position | undefined;
}

/**
 * K_KingControl is a Kaboom-specific move where the king "mind-controls" a piece located within a distance of 2 squares
 * (New York distance) from its current position, forcing the target piece to perform any of its valid moves.
 * This can affect both friendly and opponent pieces. Queens are immune to mind control.
 */
export interface KKingControl {
  /** king's current position */
  position?:
    | Position
    | undefined;
  /** The move that the target piece will perform as a result of mind control. */
  forcedMove?: KaboomMove | undefined;
}

function createBaseKaboomMove(): KaboomMove {
  return {
    cPawnMove: undefined,
    cPawnCapture: undefined,
    kPawnBump: undefined,
    kPawnExplosion: undefined,
    cKnightMove: undefined,
    cKnightCapture: undefined,
    kKnightBump: undefined,
    kKnightStomp: undefined,
    cBishopMove: undefined,
    cBishopCapture: undefined,
    kBishopBump: undefined,
    kBishopSnipe: undefined,
    cRookMove: undefined,
    cRookCapture: undefined,
    kRookBump: undefined,
    kRookTackle: undefined,
    cQueenMove: undefined,
    cQueenCapture: undefined,
    kQueenBump: undefined,
    kQueenNova: undefined,
    cKingMove: undefined,
    cKingCapture: undefined,
    kKingBump: undefined,
    kKingControl: undefined,
  };
}

export const KaboomMove = {
  encode(message: KaboomMove, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cPawnMove !== undefined) {
      CPawnMove.encode(message.cPawnMove, writer.uint32(82).fork()).ldelim();
    }
    if (message.cPawnCapture !== undefined) {
      CPawnCapture.encode(message.cPawnCapture, writer.uint32(90).fork()).ldelim();
    }
    if (message.kPawnBump !== undefined) {
      KPawnBump.encode(message.kPawnBump, writer.uint32(98).fork()).ldelim();
    }
    if (message.kPawnExplosion !== undefined) {
      KPawnExplosion.encode(message.kPawnExplosion, writer.uint32(106).fork()).ldelim();
    }
    if (message.cKnightMove !== undefined) {
      CKnightMove.encode(message.cKnightMove, writer.uint32(162).fork()).ldelim();
    }
    if (message.cKnightCapture !== undefined) {
      CKnightCapture.encode(message.cKnightCapture, writer.uint32(170).fork()).ldelim();
    }
    if (message.kKnightBump !== undefined) {
      KKnightBump.encode(message.kKnightBump, writer.uint32(178).fork()).ldelim();
    }
    if (message.kKnightStomp !== undefined) {
      KKnightStomp.encode(message.kKnightStomp, writer.uint32(186).fork()).ldelim();
    }
    if (message.cBishopMove !== undefined) {
      CBishopMove.encode(message.cBishopMove, writer.uint32(242).fork()).ldelim();
    }
    if (message.cBishopCapture !== undefined) {
      CBishopCapture.encode(message.cBishopCapture, writer.uint32(250).fork()).ldelim();
    }
    if (message.kBishopBump !== undefined) {
      KBishopBump.encode(message.kBishopBump, writer.uint32(258).fork()).ldelim();
    }
    if (message.kBishopSnipe !== undefined) {
      KBishopSnipe.encode(message.kBishopSnipe, writer.uint32(266).fork()).ldelim();
    }
    if (message.cRookMove !== undefined) {
      CRookMove.encode(message.cRookMove, writer.uint32(322).fork()).ldelim();
    }
    if (message.cRookCapture !== undefined) {
      CRookCapture.encode(message.cRookCapture, writer.uint32(330).fork()).ldelim();
    }
    if (message.kRookBump !== undefined) {
      KRookBump.encode(message.kRookBump, writer.uint32(338).fork()).ldelim();
    }
    if (message.kRookTackle !== undefined) {
      KRookTackle.encode(message.kRookTackle, writer.uint32(346).fork()).ldelim();
    }
    if (message.cQueenMove !== undefined) {
      CQueenMove.encode(message.cQueenMove, writer.uint32(402).fork()).ldelim();
    }
    if (message.cQueenCapture !== undefined) {
      CQueenCapture.encode(message.cQueenCapture, writer.uint32(410).fork()).ldelim();
    }
    if (message.kQueenBump !== undefined) {
      KQueenBump.encode(message.kQueenBump, writer.uint32(418).fork()).ldelim();
    }
    if (message.kQueenNova !== undefined) {
      KQueenNova.encode(message.kQueenNova, writer.uint32(426).fork()).ldelim();
    }
    if (message.cKingMove !== undefined) {
      CKingMove.encode(message.cKingMove, writer.uint32(482).fork()).ldelim();
    }
    if (message.cKingCapture !== undefined) {
      CKingCapture.encode(message.cKingCapture, writer.uint32(490).fork()).ldelim();
    }
    if (message.kKingBump !== undefined) {
      KKingBump.encode(message.kKingBump, writer.uint32(498).fork()).ldelim();
    }
    if (message.kKingControl !== undefined) {
      KKingControl.encode(message.kKingControl, writer.uint32(506).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): KaboomMove {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKaboomMove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10:
          if (tag !== 82) {
            break;
          }

          message.cPawnMove = CPawnMove.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.cPawnCapture = CPawnCapture.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.kPawnBump = KPawnBump.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.kPawnExplosion = KPawnExplosion.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.cKnightMove = CKnightMove.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.cKnightCapture = CKnightCapture.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.kKnightBump = KKnightBump.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.kKnightStomp = KKnightStomp.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.cBishopMove = CBishopMove.decode(reader, reader.uint32());
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.cBishopCapture = CBishopCapture.decode(reader, reader.uint32());
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.kBishopBump = KBishopBump.decode(reader, reader.uint32());
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }

          message.kBishopSnipe = KBishopSnipe.decode(reader, reader.uint32());
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }

          message.cRookMove = CRookMove.decode(reader, reader.uint32());
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.cRookCapture = CRookCapture.decode(reader, reader.uint32());
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }

          message.kRookBump = KRookBump.decode(reader, reader.uint32());
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }

          message.kRookTackle = KRookTackle.decode(reader, reader.uint32());
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }

          message.cQueenMove = CQueenMove.decode(reader, reader.uint32());
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }

          message.cQueenCapture = CQueenCapture.decode(reader, reader.uint32());
          continue;
        case 52:
          if (tag !== 418) {
            break;
          }

          message.kQueenBump = KQueenBump.decode(reader, reader.uint32());
          continue;
        case 53:
          if (tag !== 426) {
            break;
          }

          message.kQueenNova = KQueenNova.decode(reader, reader.uint32());
          continue;
        case 60:
          if (tag !== 482) {
            break;
          }

          message.cKingMove = CKingMove.decode(reader, reader.uint32());
          continue;
        case 61:
          if (tag !== 490) {
            break;
          }

          message.cKingCapture = CKingCapture.decode(reader, reader.uint32());
          continue;
        case 62:
          if (tag !== 498) {
            break;
          }

          message.kKingBump = KKingBump.decode(reader, reader.uint32());
          continue;
        case 63:
          if (tag !== 506) {
            break;
          }

          message.kKingControl = KKingControl.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KaboomMove {
    return {
      cPawnMove: isSet(object.cPawnMove) ? CPawnMove.fromJSON(object.cPawnMove) : undefined,
      cPawnCapture: isSet(object.cPawnCapture) ? CPawnCapture.fromJSON(object.cPawnCapture) : undefined,
      kPawnBump: isSet(object.kPawnBump) ? KPawnBump.fromJSON(object.kPawnBump) : undefined,
      kPawnExplosion: isSet(object.kPawnExplosion) ? KPawnExplosion.fromJSON(object.kPawnExplosion) : undefined,
      cKnightMove: isSet(object.cKnightMove) ? CKnightMove.fromJSON(object.cKnightMove) : undefined,
      cKnightCapture: isSet(object.cKnightCapture) ? CKnightCapture.fromJSON(object.cKnightCapture) : undefined,
      kKnightBump: isSet(object.kKnightBump) ? KKnightBump.fromJSON(object.kKnightBump) : undefined,
      kKnightStomp: isSet(object.kKnightStomp) ? KKnightStomp.fromJSON(object.kKnightStomp) : undefined,
      cBishopMove: isSet(object.cBishopMove) ? CBishopMove.fromJSON(object.cBishopMove) : undefined,
      cBishopCapture: isSet(object.cBishopCapture) ? CBishopCapture.fromJSON(object.cBishopCapture) : undefined,
      kBishopBump: isSet(object.kBishopBump) ? KBishopBump.fromJSON(object.kBishopBump) : undefined,
      kBishopSnipe: isSet(object.kBishopSnipe) ? KBishopSnipe.fromJSON(object.kBishopSnipe) : undefined,
      cRookMove: isSet(object.cRookMove) ? CRookMove.fromJSON(object.cRookMove) : undefined,
      cRookCapture: isSet(object.cRookCapture) ? CRookCapture.fromJSON(object.cRookCapture) : undefined,
      kRookBump: isSet(object.kRookBump) ? KRookBump.fromJSON(object.kRookBump) : undefined,
      kRookTackle: isSet(object.kRookTackle) ? KRookTackle.fromJSON(object.kRookTackle) : undefined,
      cQueenMove: isSet(object.cQueenMove) ? CQueenMove.fromJSON(object.cQueenMove) : undefined,
      cQueenCapture: isSet(object.cQueenCapture) ? CQueenCapture.fromJSON(object.cQueenCapture) : undefined,
      kQueenBump: isSet(object.kQueenBump) ? KQueenBump.fromJSON(object.kQueenBump) : undefined,
      kQueenNova: isSet(object.kQueenNova) ? KQueenNova.fromJSON(object.kQueenNova) : undefined,
      cKingMove: isSet(object.cKingMove) ? CKingMove.fromJSON(object.cKingMove) : undefined,
      cKingCapture: isSet(object.cKingCapture) ? CKingCapture.fromJSON(object.cKingCapture) : undefined,
      kKingBump: isSet(object.kKingBump) ? KKingBump.fromJSON(object.kKingBump) : undefined,
      kKingControl: isSet(object.kKingControl) ? KKingControl.fromJSON(object.kKingControl) : undefined,
    };
  },

  toJSON(message: KaboomMove): unknown {
    const obj: any = {};
    if (message.cPawnMove !== undefined) {
      obj.cPawnMove = CPawnMove.toJSON(message.cPawnMove);
    }
    if (message.cPawnCapture !== undefined) {
      obj.cPawnCapture = CPawnCapture.toJSON(message.cPawnCapture);
    }
    if (message.kPawnBump !== undefined) {
      obj.kPawnBump = KPawnBump.toJSON(message.kPawnBump);
    }
    if (message.kPawnExplosion !== undefined) {
      obj.kPawnExplosion = KPawnExplosion.toJSON(message.kPawnExplosion);
    }
    if (message.cKnightMove !== undefined) {
      obj.cKnightMove = CKnightMove.toJSON(message.cKnightMove);
    }
    if (message.cKnightCapture !== undefined) {
      obj.cKnightCapture = CKnightCapture.toJSON(message.cKnightCapture);
    }
    if (message.kKnightBump !== undefined) {
      obj.kKnightBump = KKnightBump.toJSON(message.kKnightBump);
    }
    if (message.kKnightStomp !== undefined) {
      obj.kKnightStomp = KKnightStomp.toJSON(message.kKnightStomp);
    }
    if (message.cBishopMove !== undefined) {
      obj.cBishopMove = CBishopMove.toJSON(message.cBishopMove);
    }
    if (message.cBishopCapture !== undefined) {
      obj.cBishopCapture = CBishopCapture.toJSON(message.cBishopCapture);
    }
    if (message.kBishopBump !== undefined) {
      obj.kBishopBump = KBishopBump.toJSON(message.kBishopBump);
    }
    if (message.kBishopSnipe !== undefined) {
      obj.kBishopSnipe = KBishopSnipe.toJSON(message.kBishopSnipe);
    }
    if (message.cRookMove !== undefined) {
      obj.cRookMove = CRookMove.toJSON(message.cRookMove);
    }
    if (message.cRookCapture !== undefined) {
      obj.cRookCapture = CRookCapture.toJSON(message.cRookCapture);
    }
    if (message.kRookBump !== undefined) {
      obj.kRookBump = KRookBump.toJSON(message.kRookBump);
    }
    if (message.kRookTackle !== undefined) {
      obj.kRookTackle = KRookTackle.toJSON(message.kRookTackle);
    }
    if (message.cQueenMove !== undefined) {
      obj.cQueenMove = CQueenMove.toJSON(message.cQueenMove);
    }
    if (message.cQueenCapture !== undefined) {
      obj.cQueenCapture = CQueenCapture.toJSON(message.cQueenCapture);
    }
    if (message.kQueenBump !== undefined) {
      obj.kQueenBump = KQueenBump.toJSON(message.kQueenBump);
    }
    if (message.kQueenNova !== undefined) {
      obj.kQueenNova = KQueenNova.toJSON(message.kQueenNova);
    }
    if (message.cKingMove !== undefined) {
      obj.cKingMove = CKingMove.toJSON(message.cKingMove);
    }
    if (message.cKingCapture !== undefined) {
      obj.cKingCapture = CKingCapture.toJSON(message.cKingCapture);
    }
    if (message.kKingBump !== undefined) {
      obj.kKingBump = KKingBump.toJSON(message.kKingBump);
    }
    if (message.kKingControl !== undefined) {
      obj.kKingControl = KKingControl.toJSON(message.kKingControl);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KaboomMove>, I>>(base?: I): KaboomMove {
    return KaboomMove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KaboomMove>, I>>(object: I): KaboomMove {
    const message = createBaseKaboomMove();
    message.cPawnMove = (object.cPawnMove !== undefined && object.cPawnMove !== null)
      ? CPawnMove.fromPartial(object.cPawnMove)
      : undefined;
    message.cPawnCapture = (object.cPawnCapture !== undefined && object.cPawnCapture !== null)
      ? CPawnCapture.fromPartial(object.cPawnCapture)
      : undefined;
    message.kPawnBump = (object.kPawnBump !== undefined && object.kPawnBump !== null)
      ? KPawnBump.fromPartial(object.kPawnBump)
      : undefined;
    message.kPawnExplosion = (object.kPawnExplosion !== undefined && object.kPawnExplosion !== null)
      ? KPawnExplosion.fromPartial(object.kPawnExplosion)
      : undefined;
    message.cKnightMove = (object.cKnightMove !== undefined && object.cKnightMove !== null)
      ? CKnightMove.fromPartial(object.cKnightMove)
      : undefined;
    message.cKnightCapture = (object.cKnightCapture !== undefined && object.cKnightCapture !== null)
      ? CKnightCapture.fromPartial(object.cKnightCapture)
      : undefined;
    message.kKnightBump = (object.kKnightBump !== undefined && object.kKnightBump !== null)
      ? KKnightBump.fromPartial(object.kKnightBump)
      : undefined;
    message.kKnightStomp = (object.kKnightStomp !== undefined && object.kKnightStomp !== null)
      ? KKnightStomp.fromPartial(object.kKnightStomp)
      : undefined;
    message.cBishopMove = (object.cBishopMove !== undefined && object.cBishopMove !== null)
      ? CBishopMove.fromPartial(object.cBishopMove)
      : undefined;
    message.cBishopCapture = (object.cBishopCapture !== undefined && object.cBishopCapture !== null)
      ? CBishopCapture.fromPartial(object.cBishopCapture)
      : undefined;
    message.kBishopBump = (object.kBishopBump !== undefined && object.kBishopBump !== null)
      ? KBishopBump.fromPartial(object.kBishopBump)
      : undefined;
    message.kBishopSnipe = (object.kBishopSnipe !== undefined && object.kBishopSnipe !== null)
      ? KBishopSnipe.fromPartial(object.kBishopSnipe)
      : undefined;
    message.cRookMove = (object.cRookMove !== undefined && object.cRookMove !== null)
      ? CRookMove.fromPartial(object.cRookMove)
      : undefined;
    message.cRookCapture = (object.cRookCapture !== undefined && object.cRookCapture !== null)
      ? CRookCapture.fromPartial(object.cRookCapture)
      : undefined;
    message.kRookBump = (object.kRookBump !== undefined && object.kRookBump !== null)
      ? KRookBump.fromPartial(object.kRookBump)
      : undefined;
    message.kRookTackle = (object.kRookTackle !== undefined && object.kRookTackle !== null)
      ? KRookTackle.fromPartial(object.kRookTackle)
      : undefined;
    message.cQueenMove = (object.cQueenMove !== undefined && object.cQueenMove !== null)
      ? CQueenMove.fromPartial(object.cQueenMove)
      : undefined;
    message.cQueenCapture = (object.cQueenCapture !== undefined && object.cQueenCapture !== null)
      ? CQueenCapture.fromPartial(object.cQueenCapture)
      : undefined;
    message.kQueenBump = (object.kQueenBump !== undefined && object.kQueenBump !== null)
      ? KQueenBump.fromPartial(object.kQueenBump)
      : undefined;
    message.kQueenNova = (object.kQueenNova !== undefined && object.kQueenNova !== null)
      ? KQueenNova.fromPartial(object.kQueenNova)
      : undefined;
    message.cKingMove = (object.cKingMove !== undefined && object.cKingMove !== null)
      ? CKingMove.fromPartial(object.cKingMove)
      : undefined;
    message.cKingCapture = (object.cKingCapture !== undefined && object.cKingCapture !== null)
      ? CKingCapture.fromPartial(object.cKingCapture)
      : undefined;
    message.kKingBump = (object.kKingBump !== undefined && object.kKingBump !== null)
      ? KKingBump.fromPartial(object.kKingBump)
      : undefined;
    message.kKingControl = (object.kKingControl !== undefined && object.kKingControl !== null)
      ? KKingControl.fromPartial(object.kKingControl)
      : undefined;
    return message;
  },
};

function createBaseCPawnMove(): CPawnMove {
  return { from: undefined, to: undefined, promotion: 0 };
}

export const CPawnMove = {
  encode(message: CPawnMove, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Position.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    if (message.promotion !== 0) {
      writer.uint32(80).int32(message.promotion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CPawnMove {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCPawnMove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Position.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.promotion = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CPawnMove {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Position.fromJSON(object.to) : undefined,
      promotion: isSet(object.promotion) ? pieceKindFromJSON(object.promotion) : 0,
    };
  },

  toJSON(message: CPawnMove): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Position.toJSON(message.to);
    }
    if (message.promotion !== 0) {
      obj.promotion = pieceKindToJSON(message.promotion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CPawnMove>, I>>(base?: I): CPawnMove {
    return CPawnMove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CPawnMove>, I>>(object: I): CPawnMove {
    const message = createBaseCPawnMove();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Position.fromPartial(object.to) : undefined;
    message.promotion = object.promotion ?? 0;
    return message;
  },
};

function createBaseCPawnCapture(): CPawnCapture {
  return { from: undefined, to: undefined, promotion: 0 };
}

export const CPawnCapture = {
  encode(message: CPawnCapture, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Position.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    if (message.promotion !== 0) {
      writer.uint32(80).int32(message.promotion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CPawnCapture {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCPawnCapture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Position.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.promotion = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CPawnCapture {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Position.fromJSON(object.to) : undefined,
      promotion: isSet(object.promotion) ? pieceKindFromJSON(object.promotion) : 0,
    };
  },

  toJSON(message: CPawnCapture): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Position.toJSON(message.to);
    }
    if (message.promotion !== 0) {
      obj.promotion = pieceKindToJSON(message.promotion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CPawnCapture>, I>>(base?: I): CPawnCapture {
    return CPawnCapture.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CPawnCapture>, I>>(object: I): CPawnCapture {
    const message = createBaseCPawnCapture();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Position.fromPartial(object.to) : undefined;
    message.promotion = object.promotion ?? 0;
    return message;
  },
};

function createBaseKPawnBump(): KPawnBump {
  return { from: undefined, to: undefined, promotion: 0 };
}

export const KPawnBump = {
  encode(message: KPawnBump, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Position.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    if (message.promotion !== 0) {
      writer.uint32(80).int32(message.promotion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): KPawnBump {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKPawnBump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Position.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.promotion = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KPawnBump {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Position.fromJSON(object.to) : undefined,
      promotion: isSet(object.promotion) ? pieceKindFromJSON(object.promotion) : 0,
    };
  },

  toJSON(message: KPawnBump): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Position.toJSON(message.to);
    }
    if (message.promotion !== 0) {
      obj.promotion = pieceKindToJSON(message.promotion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KPawnBump>, I>>(base?: I): KPawnBump {
    return KPawnBump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KPawnBump>, I>>(object: I): KPawnBump {
    const message = createBaseKPawnBump();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Position.fromPartial(object.to) : undefined;
    message.promotion = object.promotion ?? 0;
    return message;
  },
};

function createBaseKPawnExplosion(): KPawnExplosion {
  return { position: undefined };
}

export const KPawnExplosion = {
  encode(message: KPawnExplosion, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): KPawnExplosion {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKPawnExplosion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KPawnExplosion {
    return { position: isSet(object.position) ? Position.fromJSON(object.position) : undefined };
  },

  toJSON(message: KPawnExplosion): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KPawnExplosion>, I>>(base?: I): KPawnExplosion {
    return KPawnExplosion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KPawnExplosion>, I>>(object: I): KPawnExplosion {
    const message = createBaseKPawnExplosion();
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseCKnightMove(): CKnightMove {
  return { from: undefined, to: undefined };
}

export const CKnightMove = {
  encode(message: CKnightMove, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Position.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CKnightMove {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCKnightMove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CKnightMove {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Position.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: CKnightMove): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Position.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CKnightMove>, I>>(base?: I): CKnightMove {
    return CKnightMove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CKnightMove>, I>>(object: I): CKnightMove {
    const message = createBaseCKnightMove();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Position.fromPartial(object.to) : undefined;
    return message;
  },
};

function createBaseCKnightCapture(): CKnightCapture {
  return { from: undefined, to: undefined };
}

export const CKnightCapture = {
  encode(message: CKnightCapture, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Position.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CKnightCapture {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCKnightCapture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CKnightCapture {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Position.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: CKnightCapture): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Position.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CKnightCapture>, I>>(base?: I): CKnightCapture {
    return CKnightCapture.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CKnightCapture>, I>>(object: I): CKnightCapture {
    const message = createBaseCKnightCapture();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Position.fromPartial(object.to) : undefined;
    return message;
  },
};

function createBaseKKnightBump(): KKnightBump {
  return { from: undefined, to: undefined, bumpDirection: 0 };
}

export const KKnightBump = {
  encode(message: KKnightBump, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Position.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    if (message.bumpDirection !== 0) {
      writer.uint32(24).int32(message.bumpDirection);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): KKnightBump {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKKnightBump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Position.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.bumpDirection = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KKnightBump {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Position.fromJSON(object.to) : undefined,
      bumpDirection: isSet(object.bumpDirection) ? kKnightBump_BumpDirectionFromJSON(object.bumpDirection) : 0,
    };
  },

  toJSON(message: KKnightBump): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Position.toJSON(message.to);
    }
    if (message.bumpDirection !== 0) {
      obj.bumpDirection = kKnightBump_BumpDirectionToJSON(message.bumpDirection);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KKnightBump>, I>>(base?: I): KKnightBump {
    return KKnightBump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KKnightBump>, I>>(object: I): KKnightBump {
    const message = createBaseKKnightBump();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Position.fromPartial(object.to) : undefined;
    message.bumpDirection = object.bumpDirection ?? 0;
    return message;
  },
};

function createBaseKKnightStomp(): KKnightStomp {
  return { from: undefined, to: undefined };
}

export const KKnightStomp = {
  encode(message: KKnightStomp, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Position.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): KKnightStomp {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKKnightStomp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KKnightStomp {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Position.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: KKnightStomp): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Position.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KKnightStomp>, I>>(base?: I): KKnightStomp {
    return KKnightStomp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KKnightStomp>, I>>(object: I): KKnightStomp {
    const message = createBaseKKnightStomp();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Position.fromPartial(object.to) : undefined;
    return message;
  },
};

function createBaseCBishopMove(): CBishopMove {
  return { from: undefined, to: undefined };
}

export const CBishopMove = {
  encode(message: CBishopMove, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Position.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CBishopMove {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCBishopMove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CBishopMove {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Position.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: CBishopMove): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Position.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CBishopMove>, I>>(base?: I): CBishopMove {
    return CBishopMove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CBishopMove>, I>>(object: I): CBishopMove {
    const message = createBaseCBishopMove();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Position.fromPartial(object.to) : undefined;
    return message;
  },
};

function createBaseCBishopCapture(): CBishopCapture {
  return { from: undefined, to: undefined };
}

export const CBishopCapture = {
  encode(message: CBishopCapture, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Position.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CBishopCapture {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCBishopCapture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CBishopCapture {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Position.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: CBishopCapture): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Position.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CBishopCapture>, I>>(base?: I): CBishopCapture {
    return CBishopCapture.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CBishopCapture>, I>>(object: I): CBishopCapture {
    const message = createBaseCBishopCapture();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Position.fromPartial(object.to) : undefined;
    return message;
  },
};

function createBaseKBishopBump(): KBishopBump {
  return { from: undefined, to: undefined };
}

export const KBishopBump = {
  encode(message: KBishopBump, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Position.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): KBishopBump {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKBishopBump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KBishopBump {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Position.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: KBishopBump): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Position.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KBishopBump>, I>>(base?: I): KBishopBump {
    return KBishopBump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KBishopBump>, I>>(object: I): KBishopBump {
    const message = createBaseKBishopBump();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Position.fromPartial(object.to) : undefined;
    return message;
  },
};

function createBaseKBishopSnipe(): KBishopSnipe {
  return { from: undefined, target: undefined };
}

export const KBishopSnipe = {
  encode(message: KBishopSnipe, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.target !== undefined) {
      Position.encode(message.target, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): KBishopSnipe {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKBishopSnipe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.target = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KBishopSnipe {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      target: isSet(object.target) ? Position.fromJSON(object.target) : undefined,
    };
  },

  toJSON(message: KBishopSnipe): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.target !== undefined) {
      obj.target = Position.toJSON(message.target);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KBishopSnipe>, I>>(base?: I): KBishopSnipe {
    return KBishopSnipe.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KBishopSnipe>, I>>(object: I): KBishopSnipe {
    const message = createBaseKBishopSnipe();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.target = (object.target !== undefined && object.target !== null)
      ? Position.fromPartial(object.target)
      : undefined;
    return message;
  },
};

function createBaseCRookMove(): CRookMove {
  return { from: undefined, to: undefined };
}

export const CRookMove = {
  encode(message: CRookMove, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Position.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CRookMove {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCRookMove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CRookMove {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Position.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: CRookMove): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Position.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CRookMove>, I>>(base?: I): CRookMove {
    return CRookMove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CRookMove>, I>>(object: I): CRookMove {
    const message = createBaseCRookMove();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Position.fromPartial(object.to) : undefined;
    return message;
  },
};

function createBaseCRookCapture(): CRookCapture {
  return { from: undefined, to: undefined };
}

export const CRookCapture = {
  encode(message: CRookCapture, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Position.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CRookCapture {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCRookCapture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CRookCapture {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Position.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: CRookCapture): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Position.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CRookCapture>, I>>(base?: I): CRookCapture {
    return CRookCapture.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CRookCapture>, I>>(object: I): CRookCapture {
    const message = createBaseCRookCapture();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Position.fromPartial(object.to) : undefined;
    return message;
  },
};

function createBaseKRookBump(): KRookBump {
  return { from: undefined, to: undefined };
}

export const KRookBump = {
  encode(message: KRookBump, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Position.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): KRookBump {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKRookBump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KRookBump {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Position.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: KRookBump): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Position.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KRookBump>, I>>(base?: I): KRookBump {
    return KRookBump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KRookBump>, I>>(object: I): KRookBump {
    const message = createBaseKRookBump();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Position.fromPartial(object.to) : undefined;
    return message;
  },
};

function createBaseKRookTackle(): KRookTackle {
  return { from: undefined, to: undefined };
}

export const KRookTackle = {
  encode(message: KRookTackle, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Position.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): KRookTackle {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKRookTackle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KRookTackle {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Position.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: KRookTackle): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Position.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KRookTackle>, I>>(base?: I): KRookTackle {
    return KRookTackle.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KRookTackle>, I>>(object: I): KRookTackle {
    const message = createBaseKRookTackle();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Position.fromPartial(object.to) : undefined;
    return message;
  },
};

function createBaseCQueenMove(): CQueenMove {
  return { from: undefined, to: undefined };
}

export const CQueenMove = {
  encode(message: CQueenMove, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Position.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CQueenMove {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCQueenMove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CQueenMove {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Position.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: CQueenMove): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Position.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CQueenMove>, I>>(base?: I): CQueenMove {
    return CQueenMove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CQueenMove>, I>>(object: I): CQueenMove {
    const message = createBaseCQueenMove();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Position.fromPartial(object.to) : undefined;
    return message;
  },
};

function createBaseCQueenCapture(): CQueenCapture {
  return { from: undefined, to: undefined };
}

export const CQueenCapture = {
  encode(message: CQueenCapture, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Position.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CQueenCapture {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCQueenCapture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CQueenCapture {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Position.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: CQueenCapture): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Position.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CQueenCapture>, I>>(base?: I): CQueenCapture {
    return CQueenCapture.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CQueenCapture>, I>>(object: I): CQueenCapture {
    const message = createBaseCQueenCapture();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Position.fromPartial(object.to) : undefined;
    return message;
  },
};

function createBaseKQueenBump(): KQueenBump {
  return { from: undefined, to: undefined };
}

export const KQueenBump = {
  encode(message: KQueenBump, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Position.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): KQueenBump {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKQueenBump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KQueenBump {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Position.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: KQueenBump): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Position.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KQueenBump>, I>>(base?: I): KQueenBump {
    return KQueenBump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KQueenBump>, I>>(object: I): KQueenBump {
    const message = createBaseKQueenBump();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Position.fromPartial(object.to) : undefined;
    return message;
  },
};

function createBaseKQueenNova(): KQueenNova {
  return { position: undefined };
}

export const KQueenNova = {
  encode(message: KQueenNova, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): KQueenNova {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKQueenNova();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KQueenNova {
    return { position: isSet(object.position) ? Position.fromJSON(object.position) : undefined };
  },

  toJSON(message: KQueenNova): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KQueenNova>, I>>(base?: I): KQueenNova {
    return KQueenNova.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KQueenNova>, I>>(object: I): KQueenNova {
    const message = createBaseKQueenNova();
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseCKingMove(): CKingMove {
  return { from: undefined, to: undefined };
}

export const CKingMove = {
  encode(message: CKingMove, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Position.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CKingMove {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCKingMove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CKingMove {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Position.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: CKingMove): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Position.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CKingMove>, I>>(base?: I): CKingMove {
    return CKingMove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CKingMove>, I>>(object: I): CKingMove {
    const message = createBaseCKingMove();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Position.fromPartial(object.to) : undefined;
    return message;
  },
};

function createBaseCKingCapture(): CKingCapture {
  return { from: undefined, to: undefined };
}

export const CKingCapture = {
  encode(message: CKingCapture, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Position.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CKingCapture {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCKingCapture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CKingCapture {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Position.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: CKingCapture): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Position.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CKingCapture>, I>>(base?: I): CKingCapture {
    return CKingCapture.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CKingCapture>, I>>(object: I): CKingCapture {
    const message = createBaseCKingCapture();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Position.fromPartial(object.to) : undefined;
    return message;
  },
};

function createBaseCKingCastle(): CKingCastle {
  return { kingFrom: undefined, kingTo: undefined, rookFrom: undefined, rookTo: undefined };
}

export const CKingCastle = {
  encode(message: CKingCastle, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.kingFrom !== undefined) {
      Position.encode(message.kingFrom, writer.uint32(10).fork()).ldelim();
    }
    if (message.kingTo !== undefined) {
      Position.encode(message.kingTo, writer.uint32(18).fork()).ldelim();
    }
    if (message.rookFrom !== undefined) {
      Position.encode(message.rookFrom, writer.uint32(26).fork()).ldelim();
    }
    if (message.rookTo !== undefined) {
      Position.encode(message.rookTo, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CKingCastle {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCKingCastle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kingFrom = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.kingTo = Position.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rookFrom = Position.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rookTo = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CKingCastle {
    return {
      kingFrom: isSet(object.kingFrom) ? Position.fromJSON(object.kingFrom) : undefined,
      kingTo: isSet(object.kingTo) ? Position.fromJSON(object.kingTo) : undefined,
      rookFrom: isSet(object.rookFrom) ? Position.fromJSON(object.rookFrom) : undefined,
      rookTo: isSet(object.rookTo) ? Position.fromJSON(object.rookTo) : undefined,
    };
  },

  toJSON(message: CKingCastle): unknown {
    const obj: any = {};
    if (message.kingFrom !== undefined) {
      obj.kingFrom = Position.toJSON(message.kingFrom);
    }
    if (message.kingTo !== undefined) {
      obj.kingTo = Position.toJSON(message.kingTo);
    }
    if (message.rookFrom !== undefined) {
      obj.rookFrom = Position.toJSON(message.rookFrom);
    }
    if (message.rookTo !== undefined) {
      obj.rookTo = Position.toJSON(message.rookTo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CKingCastle>, I>>(base?: I): CKingCastle {
    return CKingCastle.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CKingCastle>, I>>(object: I): CKingCastle {
    const message = createBaseCKingCastle();
    message.kingFrom = (object.kingFrom !== undefined && object.kingFrom !== null)
      ? Position.fromPartial(object.kingFrom)
      : undefined;
    message.kingTo = (object.kingTo !== undefined && object.kingTo !== null)
      ? Position.fromPartial(object.kingTo)
      : undefined;
    message.rookFrom = (object.rookFrom !== undefined && object.rookFrom !== null)
      ? Position.fromPartial(object.rookFrom)
      : undefined;
    message.rookTo = (object.rookTo !== undefined && object.rookTo !== null)
      ? Position.fromPartial(object.rookTo)
      : undefined;
    return message;
  },
};

function createBaseKKingBump(): KKingBump {
  return { from: undefined, to: undefined };
}

export const KKingBump = {
  encode(message: KKingBump, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Position.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Position.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): KKingBump {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKKingBump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Position.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KKingBump {
    return {
      from: isSet(object.from) ? Position.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Position.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: KKingBump): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Position.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Position.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KKingBump>, I>>(base?: I): KKingBump {
    return KKingBump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KKingBump>, I>>(object: I): KKingBump {
    const message = createBaseKKingBump();
    message.from = (object.from !== undefined && object.from !== null) ? Position.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Position.fromPartial(object.to) : undefined;
    return message;
  },
};

function createBaseKKingControl(): KKingControl {
  return { position: undefined, forcedMove: undefined };
}

export const KKingControl = {
  encode(message: KKingControl, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(10).fork()).ldelim();
    }
    if (message.forcedMove !== undefined) {
      KaboomMove.encode(message.forcedMove, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): KKingControl {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKKingControl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.forcedMove = KaboomMove.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KKingControl {
    return {
      position: isSet(object.position) ? Position.fromJSON(object.position) : undefined,
      forcedMove: isSet(object.forcedMove) ? KaboomMove.fromJSON(object.forcedMove) : undefined,
    };
  },

  toJSON(message: KKingControl): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    if (message.forcedMove !== undefined) {
      obj.forcedMove = KaboomMove.toJSON(message.forcedMove);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KKingControl>, I>>(base?: I): KKingControl {
    return KKingControl.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KKingControl>, I>>(object: I): KKingControl {
    const message = createBaseKKingControl();
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    message.forcedMove = (object.forcedMove !== undefined && object.forcedMove !== null)
      ? KaboomMove.fromPartial(object.forcedMove)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
