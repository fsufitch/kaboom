"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.19.6
// source: piece.proto
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChessPiece = exports.Color = exports.PieceType = exports.protobufPackage = void 0;
exports.pieceTypeFromJSON = pieceTypeFromJSON;
exports.pieceTypeToJSON = pieceTypeToJSON;
exports.colorFromJSON = colorFromJSON;
exports.colorToJSON = colorToJSON;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const position_1 = require("./position");
exports.protobufPackage = "kaboomproto";
var PieceType;
(function (PieceType) {
    PieceType[PieceType["INVALID_PIECE"] = 0] = "INVALID_PIECE";
    PieceType[PieceType["PAWN"] = 1] = "PAWN";
    PieceType[PieceType["KNIGHT"] = 2] = "KNIGHT";
    PieceType[PieceType["BISHOP"] = 3] = "BISHOP";
    PieceType[PieceType["ROOK"] = 4] = "ROOK";
    PieceType[PieceType["QUEEN"] = 5] = "QUEEN";
    PieceType[PieceType["KING"] = 6] = "KING";
    PieceType[PieceType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(PieceType || (exports.PieceType = PieceType = {}));
function pieceTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "INVALID_PIECE":
            return PieceType.INVALID_PIECE;
        case 1:
        case "PAWN":
            return PieceType.PAWN;
        case 2:
        case "KNIGHT":
            return PieceType.KNIGHT;
        case 3:
        case "BISHOP":
            return PieceType.BISHOP;
        case 4:
        case "ROOK":
            return PieceType.ROOK;
        case 5:
        case "QUEEN":
            return PieceType.QUEEN;
        case 6:
        case "KING":
            return PieceType.KING;
        case -1:
        case "UNRECOGNIZED":
        default:
            return PieceType.UNRECOGNIZED;
    }
}
function pieceTypeToJSON(object) {
    switch (object) {
        case PieceType.INVALID_PIECE:
            return "INVALID_PIECE";
        case PieceType.PAWN:
            return "PAWN";
        case PieceType.KNIGHT:
            return "KNIGHT";
        case PieceType.BISHOP:
            return "BISHOP";
        case PieceType.ROOK:
            return "ROOK";
        case PieceType.QUEEN:
            return "QUEEN";
        case PieceType.KING:
            return "KING";
        case PieceType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
var Color;
(function (Color) {
    Color[Color["INVALID_COLOR"] = 0] = "INVALID_COLOR";
    Color[Color["WHITE"] = 1] = "WHITE";
    Color[Color["BLACK"] = 2] = "BLACK";
    Color[Color["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Color || (exports.Color = Color = {}));
function colorFromJSON(object) {
    switch (object) {
        case 0:
        case "INVALID_COLOR":
            return Color.INVALID_COLOR;
        case 1:
        case "WHITE":
            return Color.WHITE;
        case 2:
        case "BLACK":
            return Color.BLACK;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Color.UNRECOGNIZED;
    }
}
function colorToJSON(object) {
    switch (object) {
        case Color.INVALID_COLOR:
            return "INVALID_COLOR";
        case Color.WHITE:
            return "WHITE";
        case Color.BLACK:
            return "BLACK";
        case Color.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseChessPiece() {
    return { type: 0, color: 0, position: undefined };
}
exports.ChessPiece = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.color !== 0) {
            writer.uint32(16).int32(message.color);
        }
        if (message.position !== undefined) {
            position_1.Position.encode(message.position, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChessPiece();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.color = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.position = position_1.Position.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? pieceTypeFromJSON(object.type) : 0,
            color: isSet(object.color) ? colorFromJSON(object.color) : 0,
            position: isSet(object.position) ? position_1.Position.fromJSON(object.position) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.type !== 0) {
            obj.type = pieceTypeToJSON(message.type);
        }
        if (message.color !== 0) {
            obj.color = colorToJSON(message.color);
        }
        if (message.position !== undefined) {
            obj.position = position_1.Position.toJSON(message.position);
        }
        return obj;
    },
    create(base) {
        return exports.ChessPiece.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseChessPiece();
        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;
        message.color = (_b = object.color) !== null && _b !== void 0 ? _b : 0;
        message.position = (object.position !== undefined && object.position !== null)
            ? position_1.Position.fromPartial(object.position)
            : undefined;
        return message;
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=piece.js.map