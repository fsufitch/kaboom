// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.19.6
// source: game.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Color, colorFromJSON, colorToJSON } from "./color";
import { Effect } from "./effect";
import { Intent } from "./intent";
import { ChessPiece } from "./piece";

export const protobufPackage = "kaboomproto";

export interface Game {
  uuid: string;
  boards: Board[];
  players: Player[];
  pieces: ChessPiece[];
  turns: Turn[];
}

export interface Player {
  uuid: string;
  name: string;
}

export interface Board {
  uuid: string;
  winningPlayerUuid: string;
  playerColors: PlayerColor[];
}

export interface PlayerColor {
  playerUuid: string;
  color: Color;
}

/**
 * Turn represents a single turn taken by a player in the game.
 * It includes the player's intents (what they "do") and the resulting effects (what "happens").
 * Note: there can be multiple intents, to accommodate "bughouse" mechanics.
 */
export interface Turn {
  uuid: string;
  playerUuid: string;
  intents: Intent[];
  effects: Effect[];
}

function createBaseGame(): Game {
  return { uuid: "", boards: [], players: [], pieces: [], turns: [] };
}

export const Game = {
  encode(message: Game, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    for (const v of message.boards) {
      Board.encode(v!, writer.uint32(162).fork()).ldelim();
    }
    for (const v of message.players) {
      Player.encode(v!, writer.uint32(242).fork()).ldelim();
    }
    for (const v of message.pieces) {
      ChessPiece.encode(v!, writer.uint32(322).fork()).ldelim();
    }
    for (const v of message.turns) {
      Turn.encode(v!, writer.uint32(402).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Game {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.boards.push(Board.decode(reader, reader.uint32()));
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.players.push(Player.decode(reader, reader.uint32()));
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }

          message.pieces.push(ChessPiece.decode(reader, reader.uint32()));
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }

          message.turns.push(Turn.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Game {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      boards: globalThis.Array.isArray(object?.boards) ? object.boards.map((e: any) => Board.fromJSON(e)) : [],
      players: globalThis.Array.isArray(object?.players) ? object.players.map((e: any) => Player.fromJSON(e)) : [],
      pieces: globalThis.Array.isArray(object?.pieces) ? object.pieces.map((e: any) => ChessPiece.fromJSON(e)) : [],
      turns: globalThis.Array.isArray(object?.turns) ? object.turns.map((e: any) => Turn.fromJSON(e)) : [],
    };
  },

  toJSON(message: Game): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.boards?.length) {
      obj.boards = message.boards.map((e) => Board.toJSON(e));
    }
    if (message.players?.length) {
      obj.players = message.players.map((e) => Player.toJSON(e));
    }
    if (message.pieces?.length) {
      obj.pieces = message.pieces.map((e) => ChessPiece.toJSON(e));
    }
    if (message.turns?.length) {
      obj.turns = message.turns.map((e) => Turn.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Game>, I>>(base?: I): Game {
    return Game.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Game>, I>>(object: I): Game {
    const message = createBaseGame();
    message.uuid = object.uuid ?? "";
    message.boards = object.boards?.map((e) => Board.fromPartial(e)) || [];
    message.players = object.players?.map((e) => Player.fromPartial(e)) || [];
    message.pieces = object.pieces?.map((e) => ChessPiece.fromPartial(e)) || [];
    message.turns = object.turns?.map((e) => Turn.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlayer(): Player {
  return { uuid: "", name: "" };
}

export const Player = {
  encode(message: Player, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Player {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: Player): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Player>, I>>(base?: I): Player {
    return Player.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Player>, I>>(object: I): Player {
    const message = createBasePlayer();
    message.uuid = object.uuid ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseBoard(): Board {
  return { uuid: "", winningPlayerUuid: "", playerColors: [] };
}

export const Board = {
  encode(message: Board, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.winningPlayerUuid !== "") {
      writer.uint32(42).string(message.winningPlayerUuid);
    }
    for (const v of message.playerColors) {
      PlayerColor.encode(v!, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Board {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.winningPlayerUuid = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.playerColors.push(PlayerColor.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Board {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      winningPlayerUuid: isSet(object.winningPlayerUuid) ? globalThis.String(object.winningPlayerUuid) : "",
      playerColors: globalThis.Array.isArray(object?.playerColors)
        ? object.playerColors.map((e: any) => PlayerColor.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Board): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.winningPlayerUuid !== "") {
      obj.winningPlayerUuid = message.winningPlayerUuid;
    }
    if (message.playerColors?.length) {
      obj.playerColors = message.playerColors.map((e) => PlayerColor.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Board>, I>>(base?: I): Board {
    return Board.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Board>, I>>(object: I): Board {
    const message = createBaseBoard();
    message.uuid = object.uuid ?? "";
    message.winningPlayerUuid = object.winningPlayerUuid ?? "";
    message.playerColors = object.playerColors?.map((e) => PlayerColor.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlayerColor(): PlayerColor {
  return { playerUuid: "", color: 0 };
}

export const PlayerColor = {
  encode(message: PlayerColor, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerUuid !== "") {
      writer.uint32(10).string(message.playerUuid);
    }
    if (message.color !== 0) {
      writer.uint32(16).int32(message.color);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerColor {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerColor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.playerUuid = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.color = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerColor {
    return {
      playerUuid: isSet(object.playerUuid) ? globalThis.String(object.playerUuid) : "",
      color: isSet(object.color) ? colorFromJSON(object.color) : 0,
    };
  },

  toJSON(message: PlayerColor): unknown {
    const obj: any = {};
    if (message.playerUuid !== "") {
      obj.playerUuid = message.playerUuid;
    }
    if (message.color !== 0) {
      obj.color = colorToJSON(message.color);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayerColor>, I>>(base?: I): PlayerColor {
    return PlayerColor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayerColor>, I>>(object: I): PlayerColor {
    const message = createBasePlayerColor();
    message.playerUuid = object.playerUuid ?? "";
    message.color = object.color ?? 0;
    return message;
  },
};

function createBaseTurn(): Turn {
  return { uuid: "", playerUuid: "", intents: [], effects: [] };
}

export const Turn = {
  encode(message: Turn, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.playerUuid !== "") {
      writer.uint32(18).string(message.playerUuid);
    }
    for (const v of message.intents) {
      Intent.encode(v!, writer.uint32(82).fork()).ldelim();
    }
    for (const v of message.effects) {
      Effect.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Turn {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTurn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.playerUuid = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.intents.push(Intent.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.effects.push(Effect.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Turn {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      playerUuid: isSet(object.playerUuid) ? globalThis.String(object.playerUuid) : "",
      intents: globalThis.Array.isArray(object?.intents) ? object.intents.map((e: any) => Intent.fromJSON(e)) : [],
      effects: globalThis.Array.isArray(object?.effects) ? object.effects.map((e: any) => Effect.fromJSON(e)) : [],
    };
  },

  toJSON(message: Turn): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.playerUuid !== "") {
      obj.playerUuid = message.playerUuid;
    }
    if (message.intents?.length) {
      obj.intents = message.intents.map((e) => Intent.toJSON(e));
    }
    if (message.effects?.length) {
      obj.effects = message.effects.map((e) => Effect.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Turn>, I>>(base?: I): Turn {
    return Turn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Turn>, I>>(object: I): Turn {
    const message = createBaseTurn();
    message.uuid = object.uuid ?? "";
    message.playerUuid = object.playerUuid ?? "";
    message.intents = object.intents?.map((e) => Intent.fromPartial(e)) || [];
    message.effects = object.effects?.map((e) => Effect.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
