// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.19.6
// source: kaboom.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { KaboomMove } from "./move";
import { ChessPiece } from "./piece";

export const protobufPackage = "kaboomproto";

export interface GameState {
  boards: BoardState[];
}

export interface BoardState {
  whitePlayer?: Player | undefined;
  blackPlayer?: Player | undefined;
  chessBoard?:
    | ChessBoard
    | undefined;
  /** Current turn, turn count, etc can be implied from the move history */
  moveHistory: KaboomMove[];
}

export interface Player {
  uuid: string;
  name: string;
  boardUuid: string[];
}

export interface ChessBoard {
  uuid: string;
  name: string;
  pieces: ChessPiece[];
}

function createBaseGameState(): GameState {
  return { boards: [] };
}

export const GameState = {
  encode(message: GameState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.boards) {
      BoardState.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GameState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.boards.push(BoardState.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameState {
    return {
      boards: globalThis.Array.isArray(object?.boards) ? object.boards.map((e: any) => BoardState.fromJSON(e)) : [],
    };
  },

  toJSON(message: GameState): unknown {
    const obj: any = {};
    if (message.boards?.length) {
      obj.boards = message.boards.map((e) => BoardState.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GameState>, I>>(base?: I): GameState {
    return GameState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameState>, I>>(object: I): GameState {
    const message = createBaseGameState();
    message.boards = object.boards?.map((e) => BoardState.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBoardState(): BoardState {
  return { whitePlayer: undefined, blackPlayer: undefined, chessBoard: undefined, moveHistory: [] };
}

export const BoardState = {
  encode(message: BoardState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.whitePlayer !== undefined) {
      Player.encode(message.whitePlayer, writer.uint32(10).fork()).ldelim();
    }
    if (message.blackPlayer !== undefined) {
      Player.encode(message.blackPlayer, writer.uint32(18).fork()).ldelim();
    }
    if (message.chessBoard !== undefined) {
      ChessBoard.encode(message.chessBoard, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.moveHistory) {
      KaboomMove.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BoardState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoardState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.whitePlayer = Player.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blackPlayer = Player.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.chessBoard = ChessBoard.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.moveHistory.push(KaboomMove.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BoardState {
    return {
      whitePlayer: isSet(object.whitePlayer) ? Player.fromJSON(object.whitePlayer) : undefined,
      blackPlayer: isSet(object.blackPlayer) ? Player.fromJSON(object.blackPlayer) : undefined,
      chessBoard: isSet(object.chessBoard) ? ChessBoard.fromJSON(object.chessBoard) : undefined,
      moveHistory: globalThis.Array.isArray(object?.moveHistory)
        ? object.moveHistory.map((e: any) => KaboomMove.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BoardState): unknown {
    const obj: any = {};
    if (message.whitePlayer !== undefined) {
      obj.whitePlayer = Player.toJSON(message.whitePlayer);
    }
    if (message.blackPlayer !== undefined) {
      obj.blackPlayer = Player.toJSON(message.blackPlayer);
    }
    if (message.chessBoard !== undefined) {
      obj.chessBoard = ChessBoard.toJSON(message.chessBoard);
    }
    if (message.moveHistory?.length) {
      obj.moveHistory = message.moveHistory.map((e) => KaboomMove.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BoardState>, I>>(base?: I): BoardState {
    return BoardState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BoardState>, I>>(object: I): BoardState {
    const message = createBaseBoardState();
    message.whitePlayer = (object.whitePlayer !== undefined && object.whitePlayer !== null)
      ? Player.fromPartial(object.whitePlayer)
      : undefined;
    message.blackPlayer = (object.blackPlayer !== undefined && object.blackPlayer !== null)
      ? Player.fromPartial(object.blackPlayer)
      : undefined;
    message.chessBoard = (object.chessBoard !== undefined && object.chessBoard !== null)
      ? ChessBoard.fromPartial(object.chessBoard)
      : undefined;
    message.moveHistory = object.moveHistory?.map((e) => KaboomMove.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlayer(): Player {
  return { uuid: "", name: "", boardUuid: [] };
}

export const Player = {
  encode(message: Player, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.boardUuid) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.boardUuid.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Player {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      boardUuid: globalThis.Array.isArray(object?.boardUuid)
        ? object.boardUuid.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Player): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.boardUuid?.length) {
      obj.boardUuid = message.boardUuid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Player>, I>>(base?: I): Player {
    return Player.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Player>, I>>(object: I): Player {
    const message = createBasePlayer();
    message.uuid = object.uuid ?? "";
    message.name = object.name ?? "";
    message.boardUuid = object.boardUuid?.map((e) => e) || [];
    return message;
  },
};

function createBaseChessBoard(): ChessBoard {
  return { uuid: "", name: "", pieces: [] };
}

export const ChessBoard = {
  encode(message: ChessBoard, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.pieces) {
      ChessPiece.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChessBoard {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChessBoard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pieces.push(ChessPiece.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChessBoard {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      pieces: globalThis.Array.isArray(object?.pieces) ? object.pieces.map((e: any) => ChessPiece.fromJSON(e)) : [],
    };
  },

  toJSON(message: ChessBoard): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.pieces?.length) {
      obj.pieces = message.pieces.map((e) => ChessPiece.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChessBoard>, I>>(base?: I): ChessBoard {
    return ChessBoard.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChessBoard>, I>>(object: I): ChessBoard {
    const message = createBaseChessBoard();
    message.uuid = object.uuid ?? "";
    message.name = object.name ?? "";
    message.pieces = object.pieces?.map((e) => ChessPiece.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
